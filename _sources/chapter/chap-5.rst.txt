
.. _chap_5:

视觉大模型安全
==============


在视觉领域，卷积神经网络曾经是主导模型，凭借其在图像分类、目标检测和语义分割等任务中的卓越表现，成为计算机视觉领域的核心技术。卷积神经网络通过层级卷积和池化操作逐步提取图像特征，其局部感受野和参数共享机制，使其在处理图像数据时效率高且效果好。然而，随着数据量和计算能力的不断提升，对模型能力和性能的需求也越来越高，这促使研究人员探索新的模型架构。

近年来，ViT大放异彩，逐渐替代卷积神经网络成为视觉领域的主流模型。ViT借鉴了Transformer架构在自然语言处理领域的成功经验，通过处理非重叠的图像块并应用自注意力机制，捕捉全局特征。与传统的卷积神经网络不同，ViT不再依赖卷积操作，而是利用自注意力机制来捕捉图像中不同区域之间的关系，从而提供更丰富的上下文信息。这使得ViT在大型图像数据集上训练时表现出色，并在许多视觉任务中取得了显著的性能提升。关于ViT的具体介绍可以参考章节
:numref:`sec_2.2.2` .

尽管ViT在视觉任务中表现出色，但其安全性问题也引起了广泛关注。与卷积神经网络一样，ViT模型也会受到对抗样本的攻击，发生预测错误。此外，后门攻击、模型抽取、数据抽取等问题在ViT模型中也需要进一步研究和解决。在本章中，我们将深入探讨ViT模型 [1]_
的安全性问题，包括对抗攻击、对抗防御、后门攻击、后门防御、模型抽取以及深度伪造。

.. _sec_adv_attack:

对抗攻击
--------


此前的对抗攻击算法主要针对卷积神经网络设计。然而，随着ViT模型逐渐成为主流模型，研究人员开始关注ViT模型对这些攻击的鲁棒性。本节将介绍针对ViT模型的白盒攻击、迁移攻击以及查询攻击。

白盒攻击
~~~~~~~~

传统白盒攻击算法，比如FGSM、PGD、AutoAttack等，基于对抗梯度生成对抗样本，可以直接跨模型类型使用。即这些白盒攻击算法可以直接用来攻击ViT模型。针对ViT模型，当前研究首要关注的问题是\ *“ViT模型是否比传统卷积神经网络更鲁棒”*\ ？本小节简单总结介绍当前工作在这方面所取得的理解。

研究表明，ViT模型在面对不同类型的白盒攻击时，其安全性和鲁棒性表现并不优于卷积神经网络
:cite:`mahmood2021robustness`
。并且，随着扰动强度的增大，ViT模型的白盒鲁棒性甚至比传统卷积神经网络还要差。另外，基于频率视角下的研究显示，相比于传统卷积神经网络，ViT模型在应对高频扰动时表现出更强的鲁棒性
:cite:`shao2021adversarial`
。这是因为卷积神经网络更依赖图像中的高频信息进行决策，因而对高频扰动更加敏感。

考虑到ViT模型将输入图像表示为图像块的序列，这种基于图像块的输入引发了一个疑问：当个别输入图像块受到对抗扰动时，ViT的表现如何？在探讨ViT的对抗鲁棒性时，需要深入分析其在这种情况下的行为表现，并评估其相对于卷积神经网络的优势和不足。研究发现，ViT模型对自然损坏的图像块更具鲁棒性，而对于对抗扰动的图像块更不鲁棒
:cite:`gu2022vision`
。相比于卷积神经网络，ViT模型的自注意力机制极大地影响了ViT模型的鲁棒性。当图像块被自然损坏时，卷积神经网络对于自然损坏的图像块和原始干净图像块的注意力相同，而ViT模型对于自然损坏的图像块的关注少于原始干净图像块，因而对于自然损坏的图像块具有更高的鲁棒性；而当图像块被对抗扰动时，卷积神经网络依然将损坏的图像块视为正常的图像块，对于对抗扰动后的图像块的注意力和原始图像块相似，而对抗扰动的图像块则吸引了ViT模型更多的注意力，导致模型更容易被欺骗。这也使得攻击者可以通过攻击图像块的方式来攻击ViT模型，此攻击方法也被称为\ **图像块欺骗**\ （Patch-Fool）
:cite:`fu2022patch` 。

综上所述，针对ViT模型的白盒对抗鲁棒性，我们已经取得了以下理解：

-  在白盒攻击场景下，ViT模型的鲁棒性并不好，随着对抗扰动强度的增大，ViT模型的白盒鲁棒性甚至比传统卷积神经网络还要差。
-  相比卷积神经网络，ViT模型对于高频扰动更加鲁棒。
-  面对图像块级别的扰动，ViT模型对自然损坏的图像块更加鲁棒，而同时也更容易受到对抗图像块的攻击。

下面我们介绍两类主要针对ViT所提出的攻击，即迁移攻击和查询攻击。

迁移攻击
~~~~~~~~

与白盒攻击相比，迁移攻击更加贴近实际应用场景。迁移攻击不需要知道目标模型的参数细节，只需在一个替代模型上生成对抗样本，并直接应用这些样本来攻击目标模型。这使得迁移攻击在实际场景中可行性和威胁性更高。

因为ViT的特殊输入模式（图像块）会在一定程度上干扰对抗噪声，所以相比卷积神经网络，ViT模型对于迁移攻击会更鲁棒一些，并且随着模型容量的增加，模型的鲁棒性也逐渐增强。虽然ViT模型针对迁移攻击更鲁棒，但是攻击者可以利用ViT模型来生成对抗样本，并用它们来攻击别的模型（包括ViT和其他模型），带来新的安全风险。如何基于ViT来生成跨模型迁移性更好的对抗样本是一个值得研究的问题。

另外，随着“预训练-微调”范式的广泛应用，一种新的迁移攻击范式应运而生，即\ **上下游迁移攻击**\ 。这种攻击方法在预训练模型上生成对抗样本，然后用它们来攻击在下游任务上微调的模型。上下游迁移攻击利用了预训练模型与微调模型之间的继承关系，使得对抗噪声在不同训练阶段和任务之间保持有效。此类攻击不仅提升了攻击的广泛性，同时也对模型的鲁棒性提出了更高的要求。

在本小节中，我们将介绍几个基于ViT模型提出的、有代表性的跨模型迁移和上下游迁移攻击算法。

跨模型迁移攻击
^^^^^^^^^^^^^^

这里的跨模型迁移攻击主要是从ViT模型往其他模型迁移，大都借助ViT模型的图像块特点，设计不同的迁移增强技术来提升迁移性。

**自集成+词元精炼**\ ：
ViT模型将输入图像划分为若干固定大小的图像块，然后将其投影到一个高维空间中。这些嵌入向量（称为\ *视觉词元*\ ）连同一个特殊的分类词元（cls
token）一起输入到模型中。分类词元在初始时被设置为一个固定的向量，用于捕获全局信息，并在后续的层中不断更新。ViT模型通常由多个Transformer块组成，每个块包括多头自注意力模块和前馈层模块。其中，多头自注意力模块计算输入向量之间的关系，并生成加权的注意力表示。然后，前馈层模块对这些加权表示进行进一步的非线性变换。每个块的输入包括视觉词元和分类词元，每个块的输出作为下一个块的输入。经过一系列这样的处理后，最终的分类词元携带了图像的全局特征。在分类任务中，最后一个块的分类词元被输入到分类头中，通过一个全连接层进行处理，从而输出预测结果。

.. _fig_self_ensemble:

.. figure:: images/chapter5/1.png
   :width: 892px

   自集成示意图 :cite:`naseer2021improving`



传统的对抗攻击仅使用ViT中最后一个块的分类词元来生成对抗样本，丢弃了其他块的分类词元，从而导致了对抗样本的迁移性较差。\ **自集成**\ （self-ensemble）
:cite:`naseer2021improving`
方法的思路是有效地利用多个分类词元来生成对抗样本。如
:numref:`fig_self_ensemble`
（左图）所示，自集成策略通过将单个ViT模型分解为Transformer块的集合，找到多条判别路径，从而充分利用每个Transformer块输出的分类词元来生成对抗样本。一个包含\ :math:`n`\ 个Transformer块的ViT模型，可以记为：

.. math:: \mathcal{F}=\left(f_1 \circ f_2 \circ f_3 \circ \ldots f_n\right) \circ g
   :label: eq_vit

其中，\ :math:`f_i`\ 表示一个由多头自注意力模块和前馈层模块组成的单个Transformer块，\ :math:`g`\ 是最终的分类头。自集成的策略充分利用每个Transformer块，并且使用共享的分类头作为一条判别路径。例如，使用第\ :math:`k`\ 个Transformer块的分类词元来分类的公式可表示如下：

.. math:: \begin{split}\mathcal{F}_k=\left(\prod_{i=1}^k f_i\right) \circ g, \quad \text {其中} \quad k=1,2, \ldots, n\end{split}
   :label: eq_self_ensemble

因此，对于一个包含\ :math:`n`\ 个Transformer块的ViT模型，一共可以得到\ :math:`n`\ 条判别路径。对于无目标攻击，使用自集成策略的对抗优化目标为：

.. math:: \begin{split}\max _{{\boldsymbol{x}}'} \sum_{k=1}^n \mathbb{1}[ \mathcal{F}_k\left({\boldsymbol{x}}'\right)_{\text {argmax}} \neq y ], \quad \text { s.t. }\left\|{\boldsymbol{x}}-{\boldsymbol{x}}'\right\|_p \leq \epsilon\end{split}
   :label: eq_self_ensemble_1

其中，\ :math:`\mathbb{1}[\cdot]`\ 为指示函数。类似的，有目标攻击的优化目标可以对应的写成最小化到目标类别的损失。

由于在ViT的训练过程中，只有最后一个Transformer块的分类词元被输入到分类头中，这意味着其它块输出的分类词元与共享的分类头\ :math:`g`\ 并没有对齐，从而导致分类性能不佳。对此，可以使用\ **词元精炼策略**\ （token
refinement）让每个块输出的分类词元与最终的分类头\ :math:`g`\ 对齐，并提高它们的判别能力，从而有助于提高对抗攻击的迁移性。如
:numref:`fig_token_refinement`
（右图）所示，词元精炼模块将每个块的分类词元输入到一个多层感知器中，同时将所有视觉词元输入到一个卷积模块中并进行池化操作，二者输出融合后作为最终分类头的输入。在此基础上，可以通过训练多层感知器和卷积模块使各分类词元、视觉词元和分类头对齐。

.. _fig_token_refinement:

.. figure:: images/chapter5/2.png
   :width: 900px

   左图：使用了自集成以及词元精炼的ViT模型；右图：词元精炼模块
   :cite:`naseer2021improving` 。



实验表明，自集成和词元精炼方法可以明显改善在ViT模型上生成的对抗样本的迁移性。但是此方法仍存在一定的局限性，比如对于分类词元的依赖很高，而且词元精炼模块的训练也会带来一定的计算开销。

.. _fig_PNA:

.. figure:: images/chapter5/3.png
   :width: 309px

   PNA攻击示意图 :cite:`wei2022towards`



**PNA+PatchOut**\ ：
在ViT模型中，多头自注意力模块使用多个平行的自注意力头来学习输入序列的不同部分之间的关系。最终，多头输出会进行拼接和投影，将来自不同特征子空间的信息组合起来。
研究发现，不同图像块之间过强的交互反而会影响生成对抗样本的迁移性。针对此问题，\ **PNA**\ （Pay
No Attention） :cite:`wei2022towards`
方法在反向传播过程中忽略自注意力分支，从而防止不同图像块之间过强的交互，如
:numref:`fig_PNA` 所示。这一方法被证明可以提高对抗样本的迁移性。

对抗噪声对源模型的过拟合是导致其迁移性差的一个主要原因。对此，\ **PatchOut**\ 方法在生成对抗样本的每轮迭代中，随机选择一部分图像块来进行更新，这可以有效地减轻过拟合现象。其攻击的目标函数可以表示为：

.. math:: \begin{split}\underset{\delta}{\mathop{\mathrm{arg\,max}} } \; \mathcal{L}(f({\boldsymbol{x}}+M \odot \delta), y)+\lambda\|\delta\|_2, \quad \text { s.t. }\|\delta\|_{\infty}<\epsilon\end{split}
   :label: eq_patchout

其中，\ :math:`\mathcal{L}`\ 表示损失函数（如常用的交叉熵损失），\ :math:`M \in\{0,1\}^{H \times W \times C}`\ 表示掩码矩阵。如果输入的图像块\ :math:`{\boldsymbol{x}}_p^i`\ 被随机选中为保留，则\ :math:`M`\ 对应位置的掩码值为1，否则为0。通过掩码矩阵\ :math:`M`\ 可以控制随机选择哪些图像块进行更新。式
:eq:`eq_patchout` 中的第二项使得扰动具有较大的\ :math:`L_2`\ 范数。
实验证明，PNA方法和PatchOut方法可以有效地增强对抗样本的迁移性。

上下游迁移攻击
^^^^^^^^^^^^^^

“预训练-微调”已经成为计算机视觉领域的主流范式（其他领域也是如此），推动大模型在各垂直领域的广泛应用。视觉领域的预训练通常使用自监督学习方法在大规模图像数据集上训练一个强大的特征提取器，以此来学习丰富的特征表示。在微调阶段，我们在下游数据集上对预训练模型进行微调，使其适配各类下游任务，如图像分类、目标检测和图像分割等。预训练-微调范式引发了新的迁移安全风险。由于预训练模型和下游微调后的模型无论是在模型架构方面，还是在模型参数方面，都高度同质化。因此，基于预训练模型生成的对抗样本可以轻易的迁移到下游微调模型。我们给这种新的迁移范式，称为\ **上下游迁移攻击**\ 。接下来，我们将介绍两种上下游迁移攻击的方法，以便读者对此有更详细的了解。

**低层提升攻击**\ ：
神经网络具有强大的特征提取能力，不同隐藏层提取的特征也有所不同。在视觉任务中，浅层通常提取图像中的一些通用特征，比如纹理、颜色等，而深层提取的特征则更加与任务相关，这些特征通常是语义级别的，包括对象类别、场景理解和复杂模式等。在微调过程中，越深层的参数变化越大，而浅层的参数大都保持不变或者变化很小。由于不同数据集的图像共享类似的浅层特征，所以\ **低层提升攻击**\ （Low-level
Layer Lifting Attack，L4A） :cite:`ban2022pre`
选择低层（浅层）特征进行攻击，以增强对抗样本的迁移性。具体来说，L4A攻击通过最大化浅层特征输出来生成对抗样本，这一过程可以形式化表示为：

.. math:: \min _{\boldsymbol{\delta}} \mathcal{L}_{base}\left(f_{\boldsymbol{\theta}}, {\boldsymbol{x}}, \boldsymbol{\delta}\right)=-\mathbb{E}_{{\boldsymbol{x}} \sim D_p}\left[\left\|f_{\boldsymbol{\theta}}^k({\boldsymbol{x}}+\boldsymbol{\delta})\right\|_F^2\right]
   :label: eq_L_base

其中，\ :math:`\|\cdot\|_F`\ 表示F-范数，\ :math:`f_{\boldsymbol{\theta}}^k({\boldsymbol{x}}+\boldsymbol{\delta})`\ 表示模型第\ :math:`k`\ 层输出的特征。实验发现，\ :math:`k`\ 越小，即选择攻击的层越浅，生成对抗样本的迁移性就越好。可以通过选择多个浅层同时进行攻击，来进一步提升效果，改进后的方法可以表示为：

.. math:: \min _{\boldsymbol{\delta}} \mathcal{L}_{fuse}\left(f_{\boldsymbol{\theta}}, {\boldsymbol{x}}, \boldsymbol{\delta}\right)=-\mathbb{E}_{{\boldsymbol{x}} \sim D_p}\left[\left\|f_{\boldsymbol{\theta}}^{k_1}({\boldsymbol{x}}+\boldsymbol{\delta})\right\|_F^2+\lambda \cdot\left\|f_{\boldsymbol{\theta}}^{k_2}({\boldsymbol{x}}+\boldsymbol{\delta})\right\|_F^2\right]
   :label: eq_L_fuse

其中，\ :math:`k_1`\ 和\ :math:`k_2`\ 是选择攻击的第\ :math:`k_1`\ 和\ :math:`k_2`\ 层，参数\ :math:`\lambda`
用于平衡不同层之间的重要性。

由于预训练数据集和微调数据集在统计分布上往往存在较大差异，且在生成对抗样本的过程中并不知道微调数据集的信息，因此，生成的对抗噪声可能会过拟合到预训练模型和数据分布，从而导致迁移性差。对此，L4A攻击进一步使用不同均值和方差的高斯噪声来防止过拟合，可行形式化表示为：

.. math:: \min _{\boldsymbol{\delta}} \mathcal{L}_{u g s}\left(f_{\boldsymbol{\theta}}, {\boldsymbol{x}}, \boldsymbol{\delta}\right)=-\mathbb{E}_{\boldsymbol{\mu}, \boldsymbol{\sigma}, \mathbf{n}_0 \sim N(\boldsymbol{\mu}, \boldsymbol{\sigma})}\left\{\mathbb{E}_{{\boldsymbol{x}} \sim \mathcal{D}_p}\left[\left\|f_{\boldsymbol{\theta}}^k({\boldsymbol{x}}+\boldsymbol{\delta})\right\|_F^2+\lambda \cdot\left\|f_{\boldsymbol{\theta}}^k\left(\mathbf{n}_0+\boldsymbol{\delta}\right)\right\|_F^2\right]\right\}
   :label: eq_L_ugs

其中，\ :math:`\boldsymbol{\mu}`\ 和\ :math:`\boldsymbol{\sigma}`\ 是从均匀分布\ :math:`U\left(\boldsymbol{\mu}_l, \boldsymbol{\mu}_h\right)`\ 和\ :math:`U\left(\boldsymbol{\sigma}_l, \boldsymbol{\sigma}_h\right)`\ 中采样得到的，而\ :math:`\boldsymbol{\mu}_l`\ 、\ :math:`\boldsymbol{\mu}_h`\ 、\ :math:`\boldsymbol{\sigma}_l`\ 和\ :math:`\boldsymbol{\sigma}_h`\ 是预定义的超参数。L4A的攻击流程如
:numref:`fig_L4A` 所示。

.. _fig_L4A:

.. figure:: images/chapter5/4.png
   :width: 900px

   低层提升攻击（L4A）示意图 :cite:`ban2022pre`



实验表明，在不同预训练方法得到的预训练模型上，L4A攻击方法都可以生成有效迁移到下游微调模型的攻击。

**对抗编码器**\ ：基于自监督学习的预训练方法通常使用大量无标签数据来预训练编码器，预训练的编码器可以用作通用特征提取器，在下游任务上展现出优秀的特征提取和泛化能力。在这个过程中，预训练的编码器起到了至关重要的作用，所以它的安全性近年来受到越来越多的关注。
在此背景下，研究者提出了\ **对抗编码器**\ （AdvEncoder）
:cite:`zhou2023downstream`
攻击，探索基于预训练的编码器生成具有高迁移性的对抗样本和图像块。

作为特征提取器，预训练编码器具有一个特性，即\ *对于相似的图像会输出相似的特征向量*\ 。这些向量在特征空间中彼此靠近，并且与其他不相似的图像距离较远。下游任务将根据这些特征向量进行决策，因此攻击者只需要在特征空间中尽可能地将对抗样本推离其初始位置即可完成攻击。但是由于下游任务不可知，在生成对抗样本时会面临两个挑战：

1. **预训练编码器缺乏监督信号**\ 。当攻击者将图像输入预训练编码器时，只会得到相应的特征向量，而不是标签。标签信号的确实使得很多已有对抗样本生成方法无法直接被用来攻击预训练编码器。如果直接在图片上添加对抗扰动，可能无法将对抗样本推出决策边界，而只是在同一类别内部移动。
2. **缺乏关于下游任务的信息**\ 。由于预训练数据集和下游微调数据集存在着较大的差异，因此微调后模型的决策边界会发生一定程度的偏移。这可能会导致这样一种情况：微调引起的决策边界变化使得原本已经偏离原始类别的对抗样本再次被下游模型正确分类。

为了解决第一个问题，考虑到图片中的高频成分对于模型决策和生成对抗扰动十分重要，AdvEncoder使用对抗噪声来改变图片中的高频信息（如纹理信息）从而影响预训练编码器的输出。这相当于将高频信息作为监督信号引导对抗样本的生成。高频信息的破坏可以有效地改变图像的语义信息，从而更容易将对抗样本推出原始的决策边界。
为了解决第二个问题，AdvEncoder使用生成网络来生成对抗噪声，借助生成网络在生成一定模式特征的能力来提高对抗扰动的泛化性，希望生成的对抗样本可以有效偏离微调后的决策边界。

.. _fig_Advencoder:

.. figure:: images/chapter5/5.png
   :width: 900px

   AdvEncoder框架图 :cite:`zhou2023downstream`



如 :numref:`fig_Advencoder`
所示，AdvEncoder包含一个对抗样本生成器\ :math:`G`\ 、一个高频滤波器\ :math:`H`\ 、以及被攻击的编码器\ :math:`E`\ 。通过将固定噪声\ :math:`z`\ 输入到对抗样本生成器\ :math:`G`\ 中，获得一个通用的对抗噪声，并将其添加到到图像上，得到对抗样本\ :math:`{\boldsymbol{x}}_{adv}`\ 。生成器\ :math:`G`\ 训练的目标函数为：

.. math:: \mathcal{L}_{G}=\alpha \mathcal{L}_{a d v}+\beta \mathcal{L}_{h f c}+\lambda \mathcal{L}_q
   :label: eq_AdvEncoder

其中，\ :math:`\mathcal{L}_{adv}`\ 是对抗损失函数，\ :math:`\mathcal{L}_{hfc}`\ 是高频成分损失，\ :math:`\mathcal{L}_q`\ 是质量损失，\ :math:`\alpha`\ 、\ :math:`\beta`\ 、\ :math:`\lambda`
是预先定义好的超参数。

:math:`\mathcal{L}_{a d v}`\ 通过最大化编码器输出的干净特征向量和对抗特征向量之间的距离，增强通用对抗噪声的攻击能力。AdvEncoder采用InfoNCE
:cite:`oord2018representation`
损失来衡量预训练编码器\ :math:`E`\ 输出特征向量之间的相似性：

.. math:: \mathcal{L}_{a d v}=\log \left[\frac{\exp \left(S\left(E_\theta\left({\boldsymbol{x}}_i^{a d v}\right), E_\theta\left({\boldsymbol{x}}_i\right)\right) / \tau\right)}{\sum_{j=0}^K \exp \left(S\left(E_\theta\left({\boldsymbol{x}}_i^{a d v}\right), E_\theta\left({\boldsymbol{x}}_j\right) / \tau\right)\right)}\right]
   :label: eq_L_Adv

其中，\ :math:`S(\cdot)`\ 表示余弦相似度，\ :math:`\tau`\ 表示温度超参。

:math:`\mathcal{L}_{h f c}`\ 通过扰动图片中的高频成分来改变图像的语义特征，使对抗样本进一步远离原始样本。通过高频成分滤波器\ :math:`{\mathcal{H}}`\ 来得到图片中的高频成分，要求对抗样本的高频成分和干净样本的高频成分尽量不相似，从而使得对抗样本和干净样本在语义上不一致。\ :math:`\mathcal{L}_{h f c}`\ 的具体定义为：

.. math:: \mathcal{L}_{hfc}=-\left\|H\left({\boldsymbol{x}}^{adv}\right)-H({\boldsymbol{x}})\right\|_2
   :label: eq_L_hfc

为了实现更好的隐蔽性，使用质量损失\ :math:`\mathcal{L}_q`\ 来控制生成器输出的对抗噪声幅度：

.. math:: \mathcal{L}_q=\left\|{\boldsymbol{x}}^{a d v}-{\boldsymbol{x}}\right\|_2

在不改变AdvEncoder框架的情况下，可以将生成的通用对抗噪声应用于两种常见的攻击形式：（1）添加到全图的、隐蔽的对抗扰动，添加过程可以表示为
:eq:`eq_adv` ；（2）添加到图像块上的对抗扰动，添加过程可以表示为
:eq:`eq_adv_patch`
。其中，\ :math:`\odot`\ 表示逐元素相乘，\ :math:`m`\ 是一个二元矩阵，包含对抗扰动图像块的位置信息。

.. math:: {\boldsymbol{x}}^{a d v}={\boldsymbol{x}}+ G(z)
   :label: eq_adv

.. math:: {\boldsymbol{x}}^{adv}={\boldsymbol{x}} \odot(1-m)+G(z) \odot m
   :label: eq_adv_patch

查询攻击
~~~~~~~~

查询攻击是一种黑盒攻击方法，其通过多次查询目标模型来估计对抗梯度信息，从而可以攻击完全黑盒的模型。在攻击ViT模型时，可以利用模型的特性来设计查询策略，从而可以以更少的查询次数获得更准确的攻击。一方面，与卷积神经网络相比，ViT的整体噪声敏感度较低。为了找到初始的对抗样本，针对ViT模型查询攻击需要添加更大幅度的随机噪声。然而，大的初始噪声在攻击过程中更难压缩（使其满足\ :math:`\epsilon`\ 限制）。另一方面，ViT将图像分割为多个非重叠的图像块，这降低了噪声对最终分类结果的影响。这同样也会降低黑盒查询攻击在ViT上的成功率。所以，针对ViT模型的黑盒查询攻击是一个很有挑战性的问题。下面将介绍一种可以部分解决这些挑战的攻击方法。

逐图像块对抗消除
^^^^^^^^^^^^^^^^

对于ViT模型\ :math:`f`\ ，向干净样本\ :math:`{\boldsymbol{x}}`\ 添加对抗扰动\ :math:`z`\ 后得到对应的对抗样本\ :math:`{\boldsymbol{x}}^{\prime} = {\boldsymbol{x}} + z`\ ，该对抗样本可以让模型做出错误预测\ :math:`f\left({\boldsymbol{x}}^{\prime}\right) \neq f({\boldsymbol{x}})`\ 。选定一个宽为\ :math:`w`\ ，高为\ :math:`h`\ ，左上角坐标为\ :math:`(sr, sc)`\ 的图像块，对其进行压缩后得到新的对抗噪声\ :math:`\tilde{z}`\ ：

.. math:: \tilde{z}(s r, s c, h, w, \kappa)_{r, c}=\left\{\begin{array}{l}z_{r, c} \cdot \kappa, \quad \text { if } s r \leq r<s r+h \text { and } s c \leq c<s c+w, \\z_{r, c}\end{array}\right.
   :label: eq_PAR_z_1

其中，\ :math:`r`\ 和\ :math:`c`\ 分别是噪声\ :math:`z`\ 中像素的行列坐标，\ :math:`\kappa \in[0,1]`
是噪声的压缩比率。

定义图像块的噪声敏感度\ :math:`sens`\ 为模型\ :math:`f`\ 错误分类\ :math:`{\boldsymbol{x}} + \tilde{z}`\ 所需的最小噪声压缩比\ :math:`\kappa_{m i n }`\ ，可形式化表示为：

.. math:: \begin{aligned}& \operatorname{sens}\left(f, {\boldsymbol{x}}, {\boldsymbol{x}}^{\prime}, s r, s c, h, w\right)=\kappa_{\text {min }}                                                \\& \text { s.t. } \quad f\left({\boldsymbol{x}}+\tilde{z}\left(s r, s c, h, w, \kappa_{min}\right)\right) \neq f({\boldsymbol{x}})                                     \\& \text { and } \forall \kappa^{\prime}<\kappa_{min }, \quad f\left({\boldsymbol{x}}+\tilde{z}\left(s r, s c, h, w, \kappa^{\prime}\right)\right)=f({\boldsymbol{x}}) \\\end{aligned}
   :label: eq_PAR_sen

噪声敏感度\ :math:`sens`\ 衡量了生成对抗性样本所需要的最小噪声量。较小的噪声敏感度意味着在不改变错误结果的情况下，可以去除更多的噪声。
研究发现，在噪声压缩的过程中，噪声敏感度更高的图像块更容易造成查询失败。同时发现，在ViT模型中，不同图像块的噪声敏感度差异很大。

理想情况下，基于查询的攻击应首先压缩\ *噪声敏感度低*\ 和\ *噪声扰动幅度大*\ 的区域。通过这种方式，既可以保证查询的成功率和单步噪声压缩的幅度，又可以在有限的查询次数下最大化噪声压缩效率。基于此想法，
**逐图像块对抗消除**\ （Patch-wise Adversarial Removal，PAR）
:cite:`shi2022decision`
方法通过一个由粗到细的搜索过程将图像划分为图像块，并分别压缩每个图像块上的噪声。PAR记录每个图像块的噪声扰动幅度和噪声敏感度，并选择具有最高查询值的图像块进行噪声压缩。此外，PAR也可以为其他查询攻击提供噪声初始化，在不引入额外计算的基础上，提高噪声压缩的效率。

如 :numref:`fig_PAR_noise_compression`
所示，PAR将初始噪声划分为图像块，探测它们的噪声敏感度，并以图像块为单位压缩噪声。具体来说，PAR通过维护两个掩码矩阵来指导探测过程，分别记录目标模型的噪声敏感度和每个图像块的噪声幅度。由于在黑盒攻击场景下无法获取目标ViT模型的详细信息，PAR不假设ViT的图像块大小，而是从一个较大的图像块大小开始进行多轮的由粗到细的搜索。

.. _fig_PAR_noise_compression:

.. figure:: images/chapter5/7.png
   :width: 886px

   PAR的噪声压缩过程 :cite:`shi2022decision`



首先，PAR初始化一个形状为\ :math:`PS_0 \times PS_0`\ 的噪声敏感度掩码\ :math:`M_S`\ 和噪声幅度掩码\ :math:`M_N`\ ，\ :math:`PS_0`\ 是一个超参数，表示PAR初始使用的图像块大小。用初始对抗样本\ :math:`{\boldsymbol{x}}^{i n i t}`\ 中每个图像块噪声幅度的\ :math:`L_2`\ 范数来初始化\ :math:`M_N`\ ：

.. math:: M_N(\text {row }, \mathrm{col})=\sqrt{\sum_{i=\text { row } * P S_0+1}^{(r o w+1) * P S_0} \sum_{j=c o l * P S_0+1}^{(r o w+1)*P S_0} \left({\boldsymbol{x}}_{i, j}^{i n i t}-{\boldsymbol{x}}_{i, j}\right)^2}
   :label: eq_PAR_initialize_MN

其中，row 和 col
分别表示\ :math:`M_N`\ 中行和列的下标，且\ :math:`\text {row, col} \in\left[1, P S_0\right]`\ 。噪声敏感度掩码\ :math:`M_S`\ 是二元掩码，值为1表示对应的图像块的噪声敏感度低，值为0表示先前的噪声压缩过程失败。初始时，设置\ :math:`M_S`\ 为全1矩阵。

在每一次对目标模型进行查询之前，使用逐元素乘积来获得查询值的掩码\ :math:`M_Q`\ ：

.. math:: M_S=J_{\text {row}, \mathrm{col}},\quad M_Q=M_N \odot M_S
   :label: eq_PAR_initialize_MS

初始化掩码矩阵后，PAR开始多轮迭代搜索。

算法 :numref:`algorithm_PAR` 定义了详细的迭代搜索过程。
如果图像块不包含噪声或者之前的查询失败了，那么该图像块的查询值为0。每次迭代对\ :math:`M_Q`\ 进行降序排序，然后去除\ :math:`M_Q`\ 中最高值对应的图像块的噪声。将更新后得到的对抗样本继续输入到目标模型中进行查询，如果其仍然能够使得目标模型错误分类，则查询成功，并保留更新，利用式
:eq:`eq_PAR_initialize_MN`
更新\ :math:`M_N`\ ；否则，查询失败，不保留更新，并且在\ :math:`M_S`\ 掩码中将该图像块对应位置设置为0，防止其参与后续更新。

如果\ :math:`M_Q`\ 的和为0，则说明在当前图像块大小\ :math:`PS`\ 下，所有的图像块要么不含噪声，要么已经被查询过了。在这种情况下，缩小图像块大小，并利用式
:eq:`eq_PAR_initialize_MN` 和式 :eq:`eq_PAR_initialize_MS`
重新初始化\ :math:`M_N`\ 和\ :math:`M_N`\ ，重复之前查询探测的过程。这一轮将会进行更加细粒度的查询。当图像块大小已经到达设置的最小值\ :math:`PS_{min}`\ 或者达到最大查询次数\ :math:`T`\ 时，退出探测过程。

.. _algorithm_PAR:

.. figure:: images/5.1_par.png
   :width: 630px

   PAR 攻击算法



.. _sec_adv_defense:

对抗防御
--------


为了提高ViT模型的鲁棒性和安全性，研究人员提出了多种对抗防御方法，如大规模对抗训练、对抗微调和扩散净化等，这些方法通过不同的策略来增强模型的基础防御能力。下面将介绍这三个方面比较有代表性的对抗防御方法。

大规模对抗训练
~~~~~~~~~~~~~~

对抗训练仍是最可靠的防御方法之一，其通过在对抗样本上训练模型，使模型能够学会识别并抵抗这些恶意输入。然而，此前对抗训练的研究主要集中在小规模模型和数据集上，如ResNet-50和CIFAR-10。为了满足对鲁棒大模型日益增长的需求，研究人员正致力于提升对抗训练的规模，在大一点的模型和海量数据上进行训练。

**AdvXL** :cite:`wang2024revisiting`
是近期提出的、一种可以实现大规模对抗训练的高效对抗训练策略。AdvXL包括两个阶段：\ *轻量级预训练*\ 和\ *密集微调*\ 。在预训练阶段，其使用较低分辨率的图像和较弱的攻击进行长时间的预训练；在微调阶段，其使用全分辨率和较强的攻击进行短时间的微调。与普通的单阶段对抗训练相比，这种由弱到强（相对于攻击者）的两阶段对抗训练流程显著降低了整体训练成本，使得大规模对抗训练成为可能。

AdvXL采用预训练的CLIP文本编码器来处理包含文本描述的大规模网络抓取数据，使得在缺乏精确标签的情况下也能进行对抗训练。
在对抗训练过程中，AdvXL结合CLIP编码器进行优化，整体优化框架可表示如下：

.. math:: \min_{\theta_I} \sum_{(I_i, T_i) \in D} \max_{\delta: \|\delta\|_p \leq \epsilon_p} \mathcal{L}(f_I, f_T, I_i + \delta, T_i)

其中，\ :math:`\theta_I`\ 表示图像编码器\ :math:`f_I`\ 的参数，\ :math:`\delta`\ 表示对抗扰动，\ :math:`\epsilon_p`\ 是扰动约束的半径。\ :math:`\mathcal{L}`\ 为对比损失函数，定义如下：

.. math:: \mathcal{L}(f_I, f_T, I_i, T_i) = -\frac{1}{2n} \sum_i \left( \log \frac{\exp(h_T^i \cdot h_I^i / \tau)}{\sum_j \exp(h_T^i \cdot h_I^j / \tau)} + \log \frac{\exp(h_I^i \cdot h_T^i / \tau)}{\sum_j \exp(h_I^i \cdot h_T^j / \tau)} \right)

其中，\ :math:`n`\ 是批次大小，\ :math:`\tau`\ 是可学习的温度参数，\ :math:`I_i`\ 和\ :math:`T_i`\ 分别表示图像和文本对，\ :math:`h_I^i = f_I(I_i) / \|f_I(I_i)\|`\ 和\ :math:`h_T^i = f_T(T_i) / \|f_T(T_i)\|`\ 分别是图像和文本的归一化投影特征。

AdvXL在四个不同规模的图像数据集（ImageNet-1K, ImageNet-21K,
LAION-400M和DataComp-1B）上进行了系统的实验，验证了其在大规模数据和模型上的鲁棒性和泛化能力，为未来的大规模对抗训练提供了新方向。

对抗微调
~~~~~~~~

大规模对抗训练往往会耗费大量的计算资源，且需要海量数据的支持。这对于许多数据匮乏的任务而言，难以实现。在这种情况下，只能选择基于微调的方法，在保持准确率的同时提升模型的对抗鲁棒性。

研究发现，基于非对抗训练的预训练模型进行微调并不会带来对抗鲁棒性，其实是在微调过程中使用对抗训练（此时的对抗训练成为\ **对抗微调**\ ）也无法弥补基础模型的脆弱性。因此，使用对抗训练过的鲁棒预训练模型是获得下游对抗鲁棒性的基础。本小节所介绍的方法所使用的预训练模型也都是对抗预训练过的鲁棒模型。对抗微调通过在特定任务的数据集上微调预训练的鲁棒模型，可以实现较高的准确率和鲁棒性。这种方法不仅减少了计算资源的消耗，还避免了对大量数据的依赖，为数据匮乏的任务提供了一种高效、可靠的解决方案。接下来，我们将介绍两种有代表性的对抗微调方法。

.. _fig_Autolora:

.. figure:: images/7_8_Auto_Lora.png
   :width: 721px

   左图：标准对抗微调；右图：AutoLoRa示意图 :cite:`xu2023autolora`



**AutoLoRa**
最简单直接的对抗微调方式就是将对抗训练和微调方法结合，在微调过程中同时优化自然目标（实现高准确率）和对抗目标（实现高鲁棒性）。基于一般微调的对抗微调损失定义如下：

.. math:: \mathcal{L}_{vanilla}(D ; \theta, \beta)=\frac{1}{n} \sum_{({\boldsymbol{x}}, y) \in D}\{\underbrace{\mathcal{L}_{CE}\left(h_\theta({\boldsymbol{x}}), y\right)}_{\text {自然目标}}+\underbrace{\beta \cdot \mathcal{L}_{KL}\left(h_\theta(\tilde{{\boldsymbol{x}}}), h_\theta({\boldsymbol{x}})\right)}_{\text {对抗目标}}\}
   :label: eq_standard_robust_finetuning

AutoLoRa :cite:`xu2023autolora`
是一种基于\ **低秩自适应微调**\ （Low-Rank
Adaptation，LoRA）的对抗微调方法。 如 :numref:`fig_Autolora`
所示，AutoLoRa使用低秩的LoRa分支来解耦自然和对抗目标的优化，将对抗数据和自然数据分别输入到预训练模型的特征提取器（蓝色模块）和LoRa分支（黄色模块）中来进行解耦。
其中，预训练特征提取器进行\ *对抗训练*\ ，从而可以获得下游对抗鲁棒性；LoRa模块进行自然训练，从而提升下游泛化。另外，在自然样本上，两个模块之间通过基于KL的逻辑值对齐来保证自然知识从预训练特征提取器到LoRa模块的“迁移”。这个过程类似于知识蒸馏，LoRa分支相当于教师模型，而预训练的特征提取器相当于学生模型，通过最小化学生模型和教师模型之间的逻辑值差异，将自然知识从教师模型蒸馏到学生模型中。AutoLoRa的损失函数定义如下：

.. math:: \begin{aligned}& \mathcal{L}_{LoRa}\left(D; \theta, \boldsymbol{A}, \boldsymbol{B}, \lambda_1, \lambda_2\right)=\frac{1}{n} \sum_{({\boldsymbol{x}}, y) \in D}\{\underbrace{\lambda_1 \cdot \mathcal{L}_{CE}\left(h_{\left\{\bar{\theta}_1+\boldsymbol{B} \boldsymbol{A}, \theta_2\right\}}({\boldsymbol{x}}), y\right)}_{\text {自然目标}} \\& +\underbrace{\left(1-\lambda_1\right) \cdot \mathcal{L}_{CE}\left(h_\theta(\tilde{{\boldsymbol{x}}}), y\right)+\lambda_2 \cdot \mathcal{L}_{KL}\left(h_\theta(\tilde{{\boldsymbol{x}}}), h_{\left\{\bar{\theta}_1+\boldsymbol{B} \boldsymbol{A}, \theta_2\right\}}({\boldsymbol{x}})\right)}_{\text {对抗目标}}\}\end{aligned}
   :label: eq_autolora

其中，\ :math:`\theta = \left\{\theta_1, \theta_2\right\}`\ 表示所有可训练的参数，\ :math:`\theta_1`\ 表示预训练特征提取器的参数，\ :math:`\theta_2`\ 表示线性分类头的参数，\ :math:`\bar{\theta_1}`\ 表示\ :math:`\theta_1`\ 不需要更新。\ :math:`\boldsymbol{B} \in \mathbb{R}^{d \times r_{nat}}`\ 和\ :math:`\boldsymbol{A} \in \mathbb{R}^{r_{nat} \times v}`\ 是两个低秩矩阵，\ :math:`\boldsymbol{BA} \in \mathbb{R}^{d \times v}`\ 与特征提取器的参数\ :math:`\theta_1 \in \mathbb{R}^{d \times v}`\ 具有相同的形状。\ :math:`\lambda_1`\ 和\ :math:`\lambda_2`\ 是两个超参数，用于平衡准确率和鲁棒性。

总结来说，AutoLoRa借助LoRa分支实现了自然目标和对抗目标的解耦，同时通过蒸馏的思想使预训练特征提取器学习到了下游任务的自然知识。最终，微调后的模型展现出较高的准确率和对抗鲁棒性。值得注意的是，这里LoRa分支仅用于微调过程的解耦，在测试阶段是丢掉不用的。此外，AutoLoRa还采用了启发式的方法自动调整学习率和超参数\ :math:`\lambda_1`\ 和\ :math:`\lambda_2`\ 。

**鲁棒线性初始化**\ （Robust Linear Initialization，RoLI）
:cite:`hua2024initialization`
方法旨在从鲁棒性继承的角度进一步提升对抗微调的鲁棒性。
由于上下游数据分布的差异和“准确率-鲁棒性”权衡，直接对鲁棒预训练模型进行对抗微调智可能只得到次优结果。在微调过程中，模型往往会通过牺牲一部分预训练鲁棒性来提升其在下游任务上的准确率。接下来，我们将介绍一种对抗微调方法，其可以使微调后的模型更好地继承预训练鲁棒性。

.. _fig_RoLI:

.. figure:: images/7_7roli.png
   :width: 444px

   对鲁棒的预训练模型进行微调，蓝色：标准微调；红色：对抗微调
   :cite:`hua2024initialization` 。



实验发现，在微调鲁棒预训练模型时，仅微调线性分类头（对应的方法称为“线性探测”，Linear-Probing）在某些数据集上的表现甚至优于其他微调方法，尽管线性分类头需要调整的参数量更少。
一般认为，模型在下游任务上的鲁棒性主要来源于两个方面：一是从预训练模型中继承的鲁棒性，二是通过对抗微调获得的鲁棒性。研究发现，即使在微调过程中使用的都是干净样本，微调后的模型仍然具有一定的鲁棒性（
:numref:`fig_RoLI`
蓝色部分）。这说明，微调模型确实可以从预训练模型中继承到一定的鲁棒性。在所有的微调方法中，线性探测比其他方法更好地继承了预训练模型中的鲁棒性。这可能是因为线性探测方法通过只更新线性分类头，避免了破坏从预训练模型中继承的鲁棒特征。

通过分析比较 :numref:`fig_RoLI`
中标准微调（蓝色部分）和对抗微调（红色部分）所呈现的鲁棒性，可以看到对抗训练在微调阶段带来了额外的鲁棒性增益。
为了进一步提升模型在下游任务中的鲁棒性，\ **鲁棒线性初始化**\ 方法先通过对抗训练训练一个\ *对抗线性探测*\ 分类头，最大程度地继承预训练模型的鲁棒性，然后再进行对抗微调（如AutoLoRa），从而进一步获得鲁棒性增益。相比于标准的对抗微调，RoLI方法可以在不降低干净准确率的情况下进一步提升鲁棒性。

扩散净化
~~~~~~~~

尽管对抗训练可以带来可靠的鲁棒性提升，但是其训练开销巨大，尤其在一些数据集较大或者大模型上难以应用。相比之下，另一类基于输入净化的防御方法，依靠生成模型对输入样本中的对抗噪声进行去除，是一种更直接且实用的对抗防御策略。这种防御方法不对攻击形式和受害者模型做任何假设，可即插即用于广泛的任务场景，并可以防御未知威胁。

.. _fig_diffpure:

.. figure:: images/5.2.4diffpure.png
   :width: 613px

   DiffPure流程图 :cite:`nie2022diffusion`



**DiffPure** :cite:`nie2022diffusion`
是一种基于基础扩散模型的对抗净化方法。通过利用扩散模型的正向和反向过程，DiffPure能够在对抗样本输入分类器之前进行净化。
如 :numref:`fig_diffpure`
所示，给定一个预先训练的扩散模型，DiffPure按照前向过程以较小的扩散时间步长
:math:`t^*`
向对抗图像添加噪声，以获得加噪图像。然后，通过逆向过程从中恢复出干净的图像，并将其输入分类模型进行分类。具体而言：

-  **扩散过程**\ ：给定一个对抗样本\ :math:`{\boldsymbol{x}}_a`\ ，在时间步\ :math:`t=0`\ 开始。扩散过程通过加入少量噪声，将对抗样本\ :math:`{\boldsymbol{x}}_a`\ 扩散到时间步\ :math:`t^*`\ ，得到加噪图片\ :math:`{\boldsymbol{x}}(t^*)`\ ，扩散过程由随机微分方程\ :math:`d{\boldsymbol{x}} = f({\boldsymbol{x}}, t)dt + g(t)d\mathbf{w}`\ 得到，其目的是通过增加噪声来逐渐平滑对抗扰动。
-  **逆扩散过程**\ ：从噪声图像开始\ :math:`{\boldsymbol{x}}(t^*)`\ ，利用了扩散模型的逆向随机微分方程\ :math:`d\hat{{\boldsymbol{x}}} = [f(\hat{{\boldsymbol{x}}}, t) - g(t)^2 \nabla_{\hat{{\boldsymbol{x}}}} \log p_t(\hat{{\boldsymbol{x}}})] dt + g(t) d\bar{\mathbf{w}}`\ 逐步去噪，恢复出干净图像。

在DiffPure方法中，扩散过程通过逐步加入噪声来平滑掉对抗扰动。这个过程中存在一个关键点，即当对抗样本和干净样本的分布足够接近时（即KL散度较小时），可以通过逆向过程恢复出干净的图像。该过程可由下式表达：

.. math:: \frac{\partial \mathrm{KL}(p_t \| q_t)}{\partial t} \leq 0

其中，\ :math:`p_t`\ 和\ :math:`q_t`\ 分别表示时间\ :math:`t`\ 时刻干净样本和对抗样本的分布。通过在扩散过程中逐步加入噪声，可以确保对抗扰动逐渐被平滑掉，同时对抗样本和干净样本的分布差异（KL散度）随时间单调递减，从而实现对抗净化。

.. _sec_bd_attack:

后门攻击
--------


我们知道卷积神经网络很容易受到后门攻击的影响，但是ViT的模型设计基于自注意力机制，与卷积神经网络相比有很大的不同，是否会具有一定的后门鲁棒性呢？
因此，自从ViT模型在视觉领域取得巨大成功后，其对后门攻击的鲁棒性也受到了很多研究者的关注。研究者利用传统后门攻击算法BadNets
:cite:`2017BadNets` 和HTBA :cite:`saha2020hidden`
对ViT模型进行攻击，得到的实验结果显示，ViT也容易受到后门攻击的威胁
:cite:`subramanya2022backdoor`
。除了这些基于传统攻击的理解，本节将介绍专门针对ViT模型提出的后门攻击算法，主要包括无数据攻击、补丁攻击、多触发器攻击和量化攻击。

无数据后门
~~~~~~~~~~

**无数据后门攻击**\ （Data-free Backdoor Injection Attack，DBIA）
:cite:`lv2021dbia`
是一种针对ViT模型提出的后门攻击，其利用Transformer的自注意力机制来生成触发器，并使用\ *代理数据集*\ （surrogate
dataset）来进行投毒。 DBIA的攻击流程如 :numref:`fig_DBIA_overview`
所示，其中包含两个主要步骤：投毒代理数据生成和后门注入。

.. _fig_DBIA_overview:

.. figure:: images/5.3/DBIA_workflow.png
   :width: 688px

   左图：投毒代理数据集；右图：后门注入 :cite:`lv2021dbia`



**（1）投毒代理数据生成生成**\ ：首先选择一个代理数据集（网络爬取或者使用开源数据集），使用最小化式
:eq:`eq_DBIA_max_attention`
来对目标ViT模型的注意力信息进行迭代优化，从而生成通用的触发器，最后将触发器添加到数据集中并修改其类别为目标类别。

.. math:: \min _t \sum_{i=1}^N\left(\operatorname{Attention}(\widetilde{{\boldsymbol{x}}}_i, L)-target\_value \right)^2
   :label: eq_DBIA_max_attention

其中，\ :math:`target\_value`\ 是目标注意力值，其在触发器上具有最大的注意力值（即1），在背景上具有最小的注意力值（即0）；\ :math:`N`\ 是代理数据集的大小；\ :math:`\widetilde{{\boldsymbol{x}}}_i = (1-m) \cdot {\boldsymbol{x}}_i + m \cdot t`\ 是用触发器\ :math:`t`\ 投毒后的样本；\ :math:`\operatorname{Attention}()`\ 是一个函数，负责从目标模型中第\ :math:`L`\ 个Transformer块的多头注意力模块中计算对输入\ :math:`\widetilde{{\boldsymbol{x}}}`\ 的注意力图。

**（2）后门注入**\ ：投毒代理数据数据集一般只含有一个类别标签，即后门目标类别。如果一个模型在只有一个标签的数据集上训练，它可能会过拟合到该标签上，并将大部分样本（无论该样本包不包含触发器）预测为该标签，这样会显著影响到其在干净样本上的性能。所以，无法通过直接使用投毒代理数据集对目标模型进行微调来嵌入后门触发器。
对此，DBIA从目标ViT模型中选择一些绝对权重之和最大且连通的神经元，因为这些神经元对最终结果有者显著的影响。然后，使用PGD方法
:cite:`madry2018towards`
在投毒代理数据集上对选中的神经元进行微调，同时限制参数的调整幅度（类似对抗攻击的\ :math:`L_{\infty}`\ 限制）以确保微调后的模型在原始任务上具有不错的性能保持。微调所对应的优化问题定义如下：

.. math:: \min _{\theta_n} \sum_{i=1}^N\left(f\left(\widetilde{{\boldsymbol{x}}}_i\right)-y_t\right)^2, \text { s.t. } \quad P_{l_{\infty}\left(\theta_n, \epsilon\right)}
   :label: eq_DBIA_finetune

其中，\ :math:`\theta_n`\ 是被选中要微调的参数；\ :math:`y_t`\ 是目标类别，\ :math:`P_{l_{\infty}\left(\theta_n, \epsilon\right)}`\ 是投影算子，用于将参数调整的幅度控制在\ :math:`\epsilon`\ 范围内。DBIA在不借助原任务数据集的前提下实现了对ViT的有效攻击。

图像块后门
~~~~~~~~~~

因为ViT模型需要将输入图像划分为一系列图像块并计算图像块之间的注意力，所以它们往往比卷积神经网络更能捕获到图像块之间的全局交互信息。因此，基于图像块的扰动可以影响ViT的自注意力机制。本小结将介绍两种基于图像块的后门攻击。

**BadViT** 这是一种基于数据污染的ViT模型后门攻击方法
:cite:`yuan2023you`
，其通过设计基于图像块的触发器样式，将模型的注意力从有益于分类的图像块上转移到带有触发器的图像块上，从而使ViT模型对带有触发器的图片进行错误分类。BadViT的优化目标可形式化表示为：

.. math:: \min_{\theta} \sum_{{\boldsymbol{x}}_i \in D_{cl}} \mathcal{L}_{tr}\left(f\left({\boldsymbol{x}}_i\right), y_i\right)+\sum_{\hat{{\boldsymbol{x}}_j} \in D_{bd}} \mathcal{L}_{bd}\left(f\left(\hat{{\boldsymbol{x}}_j}\right), y^*\right)
   :label: eq_backdoor_attack_optimization

其中，\ :math:`\theta`\ 是模型\ :math:`f`\ 的参数，\ :math:`D_{c l}`\ 是干净数据，\ :math:`D_{b d}`\ 是后门数据，\ :math:`\mathcal{L}_{tr}`\ 和\ :math:`\mathcal{L}_{bd}`\ 分别代表模型在干净和后门数据上的分类损失（干净对应干净类别，后门对应后门类别），\ :math:`({\boldsymbol{x}}_i,y_i)`\ 是干净样本及其类别标签，\ :math:`\hat{{\boldsymbol{x}}}`\ 是后门样本，\ :math:`y^*`\ 是攻击的目标类别。

.. _fig_Badvit_visualization:

.. figure:: images/5.3/BadVit.png
   :width: 855px

   对DeiT模型在不同触发器（红色框为触发器位置）设定下的干净图像和后门图像的所有层的平均注意力图可视化，注意力图中较亮的颜色表示对应图像块的注意力分数更高，相比之下，BadViT触发器能够有效地吸引模型的注意力
   :cite:`yuan2023you` 。



BadViT通过最大化模型的每一层中第\ :math:`k`\ 个图像块的注意力分数（在ViT中，每个图像块的注意力分数是指其相对于其他图像块的重要性），高效构建从触发器到目标类别的映射。
其中第\ :math:`l`\ 层的注意力分数矩阵可以被表示为\ :math:`\operatorname{Attention}^l(x)=\left\{\left[A C_i^l\right] \in \mathbb{R}^K \mid i \in[1, K]\right\}`\ ，其中\ :math:`A C_i^l=\frac{1}{K} \sum_{j \in\lfloor K\rfloor} a_{i, j}^l`\ 是第\ :math:`i`\ 个图像块的平均注意力分数，\ :math:`a_{i, j}^l`\ 是第\ :math:`i`\ 个图像块相对于第\ :math:`j`\ 个图像块的注意力分数。对于一个\ :math:`L`\ 层的模型，对触发器\ :math:`t_{adv}`\ 的优化可以被表示为：

.. math:: \underset{t_{a d v}}{\arg \max } \sum_{l \in\lfloor L\rfloor} A C_k^l,  \text { s.t. } A C_k^l=\operatorname{Attention}(\hat{{\boldsymbol{x}}})[k]
   :label: eq_badvit_t_opt

可以基于上述优化目标定义基于注意力的损失函数\ :math:`\mathcal{L}_{atten}`\ 如下：

.. math:: \mathcal{L}_{atten}=\sum_{l \in\lfloor L\rfloor} \mathcal{L}_{nll}\left(-\log \left(\text { Attention }^l(\hat{{\boldsymbol{x}}}), k\right)\right.
   :label: eq_attention_loss

其中，\ :math:`\mathcal{L}_{nll}`\ 是负对数似然损失。随机初始化触发器\ :math:`t_{adv}`\ 后，采用PGD算法进行优化：

.. math:: t_{a d v}^{\prime}=t_{a d v}-\eta \cdot \nabla_{t_{a d v}} \mathcal{L}_{a t t e n}
   :label: eq_badvit_pgd

**不可见的BadViT触发器**\ ：BadViT生成的触发器是一种马赛克（如
:numref:`fig_Badvit_visualization`
），这种明显的标记在实际部署中很容易被用户察觉到。因此，BadViT的一种变体通过使用\ :math:`L_p`\ 约束来限制触发器的扰动强度，使\ :math:`t_{adv}`\ 对人眼不可见。
为了实现这一效果，其对触发器\ :math:`t_{adv}`\ 的优化过程进行如下修改：

.. math:: t_{a d v}^{\prime}=\operatorname{Clip}_\epsilon\left(t_{a d v}-\eta \cdot \nabla_{t_{a d v}} \mathcal{L}_{a t t e n}\right)
   :label: eq_invisible_optimization

其中，\ :math:`\epsilon`\ 是扰动强度的限制，\ :math:`\operatorname{Clip}_{\epsilon}`\ 是限制触发器满足\ :math:`\left\|t_{a d v}\right\|_p \leq \epsilon`\ 的裁剪操作。此外，在将触发器添加到图像上去的过程中，其采用混合比例为\ :math:`\alpha`\ 的混合策略，而不是直接将触发器粘贴到图像上，形式化表示如下:

.. math:: \hat{{\boldsymbol{x}}}=\mu_{blend}\left({\boldsymbol{x}}, t_{adv}, m\right)=(1-\alpha) {\boldsymbol{x}}+\alpha \cdot m_k \cdot t_{a d v}
   :label: eq_BadVit_blend

:numref:`fig_BadViTs_overview`
展示了BadViT的攻击流程。BadViT可以生成一个通用的、基于图像块的触发器，可以将模型的注意力吸引到在触发器所在位置，从而建立触发器和攻击目标之间的强关联，是一种能够对ViT模型的鲁棒性带来严重威胁的后门攻击方法。

.. _fig_BadViTs_overview:

.. figure:: images/7_2_1_8_BadViTs_overview.png
   :width: 720px

   BadViT攻击流程图 :cite:`yuan2023you`



**TrojViT**\ 与BadViT类似，TrojViT :cite:`zheng2023trojvit`
也利用生成的图像块触发器来进行后门攻击。TrojViT的整体攻击流程如
:numref:`fig_trojvit_trigger` 所示，生成的图像块触发器如
:numref:`fig_trojvit_example` 所示。TrojViT主要包含两个步骤：

.. _fig_trojvit_trigger:

.. figure:: images/7_2_1_10_trojvit_workflow.png
   :width: 855px

   TrojViT的攻击流程 :cite:`zheng2023trojvit`



.. _fig_trojvit_example:

.. figure:: images/7_2_1_9_trojvit_trigger.png
   :width: 148px

   TrojViT触发器示例 :cite:`zheng2023trojvit`



**（1）图像块触发器生成**\ ：这里生成的是一个由多个部分组成的图像块触发器，每个部分都会被嵌入到输入图像的关键图像块中（如
:numref:`fig_trojvit_trigger` ）。 触发器的生成主要包括两步：

**a）对图像块进行显著性排序**\ ：目的是通过排序来找到关键图像块。对于输入图片\ :math:`{\boldsymbol{x}}`\ ，
定义\ :math:`\hat{{\boldsymbol{x}}}={\boldsymbol{x}}+P \odot M`\ 为在\ :math:`{\boldsymbol{x}}`\ 上插入触发器的图片，其中\ :math:`P`\ 表示触发器的扰动，\ :math:`M`\ 是一个二进制掩码矩阵，用于指示哪些图像块有触发器，\ :math:`P \odot M`\ 表示触发器，\ :math:`\odot`\ 表示逐元素相乘。ViT模型将输入\ :math:`{\boldsymbol{x}}`\ 分成\ :math:`n`\ 个图像块，即\ :math:`\hat{{\boldsymbol{x}}} = \{\hat{{\boldsymbol{x}}}_0, \hat{{\boldsymbol{x}}}_1, ..., \hat{{\boldsymbol{x}}}_{n-1} \}`\ ，其中\ :math:`\hat{{\boldsymbol{x}}}_{i}`\ 表示第\ :math:`i`\ 个图像块，\ :math:`\hat{{\boldsymbol{x}}}_{i,j}`\ 表示第\ :math:`i`\ 个图像块中的第\ :math:`j`\ 个像素。使用像素显著分数\ :math:`\mathcal{G}_{\hat{{\boldsymbol{x}}}_{i, j}}`\ 来表示在对目标类别\ :math:`y_{k}`\ 进行攻击时，像素\ :math:`\hat{{\boldsymbol{x}}}_{i,j}`\ 的重要性。当\ :math:`\mathcal{G}_{\hat{{\boldsymbol{x}}}_{i, j}}`\ 值越大，说明像素\ :math:`\hat{{\boldsymbol{x}}}_{i,j}`\ 对于目标类别\ :math:`y_{k}`\ 的影响越大。\ :math:`\mathcal{G}_{\hat{{\boldsymbol{x}}}_{i, j}}`\ 可以通过计算损失函数\ :math:`\mathcal{L}_{C E}\left(\hat{{\boldsymbol{x}}}, y_{k}\right)`\ 对于像素\ :math:`\hat{{\boldsymbol{x}}}_{i,j}`\ 的梯度的绝对值得到。图像块
中\ :math:`\hat{{\boldsymbol{x}}}_{i}`\ 的显著性分数可以通过对该图像块内的所有像素\ :math:`\hat{{\boldsymbol{x}}}_{i,j}`\ 的显著性分数求和得到，如式
:eq:`eq_trojvit_salience_score` 所示：

.. math:: \mathcal{G}_{\hat{x}_i}=\sum_{j=1}^d \mathcal{G}_{\hat{{\boldsymbol{x}}}_{i, j}}=\sum_{j=1}^d\left|\frac{\nabla \mathcal{L}_{C E}\left(\hat{{\boldsymbol{x}}}, y_{k}\right)}{\nabla \hat{{\boldsymbol{x}}}_{i, j}}\right|
   :label: eq_trojvit_salience_score

根据图像块的显著性分数，生成逐像素块的二进制掩码矩阵\ :math:`M`\ ，以协助挑选关键图像块来进行攻击。一个图像块在\ :math:`M`\ 中用一个元素表示。如果\ :math:`M_t`\ 为1，则它对应的图像块将会替换为触发器图像块，否则它对应的图像块保持不变，如下式所示：

.. math:: M_t= \begin{cases}1, & \text { if } \mathcal{G}_{\hat{{\boldsymbol{x}}}_t} \in top\left(\mathcal{G}_{\hat{{\boldsymbol{x}}}_{[0: n-1]}}, N\right) \\ 0, & \text { otherwise }\end{cases}
   :label: eq_trojvit_choose_patch

其中，\ :math:`top(S,N)`\ 返回集合\ :math:`S`\ 前\ :math:`N`\ 个元素。即如果\ :math:`\mathcal{G}_{\hat{{\boldsymbol{x}}}_i}`\ 是集合\ :math:`\mathcal{G}_{\left.\hat{{\boldsymbol{x}}}_{[0: n-1]}\right]}`\ 中的前\ :math:`N`\ 个元素，则\ :math:`M_t`\ 值为1，否则为0。

**b）生成触发器**\ ：首先基于掩码矩阵\ :math:`M`\ ，得到触发器\ :math:`P \odot M`\ ，并使用“注意力-目标损失”（Attention-Target
Loss，ATL）来优化扰动\ :math:`P`\ 。这里通常要考虑两个要求：1）在触发器中具有扰动\ :math:`P`\ 的图像块应该比输入中没有触发器的其他图像块获得更多的注意力。这可以用\ :math:`\mathcal{L}_{ATTN}`\ 来实现，

.. math:: \mathcal{L}_{ATTN}^l(\hat{{\boldsymbol{x}}}, T)=-\log \sum_{h, i} a t t n_{i \rightarrow T}^{l, h}
   :label: eq_trojvit_L_attn

其中，\ :math:`l`\ 表示ViT的第\ :math:`l`\ 层，\ :math:`h`\ 是ViT的头，T是被选中的图像块索引的集合，对于任意的\ :math:`t \in T`\ ，都有\ :math:`M_t = 1`\ 。\ :math:`\mathcal{L}_{ATTN}^l`\ 是\ :math:`h`\ 在\ :math:`T`\ 个选定图像块上的注意力分布之和的负对数似然。
2）一旦输入图片中插入了触发器，受攻击的ViT模型应该以更大的概率输出预定义的目标类别\ :math:`y_k`\ ，可以通过交叉熵损失函数来实现。因此，ATL损失可定义为：

.. math:: \mathcal{L}_{A T L}\left(\hat{{\boldsymbol{x}}}, y_k\right)=\mathcal{L}_{C E}\left(\hat{{\boldsymbol{x}}}, y_k\right)+\lambda \cdot \sum_l^L \mathcal{L}_{ATTN}^l(\hat{{\boldsymbol{x}}}, T)
   :label: eq_trojvit_ATL

其中，\ :math:`L`\ 是ViT模型的总层数，\ :math:`\lambda`\ 是注意力损失的权重。Attention-Target
损失同时考虑了注意力损失和交叉熵损失来优化扰动\ :math:`P`\ 。
ATL损失的计算过程如 :numref:`fig_trojvit_attention_target_loss`
所示，其中\ :math:`{\boldsymbol{x}}_1`\ ，\ :math:`{\boldsymbol{x}}_2`\ 都是干净的图像块，\ :math:`\hat{{\boldsymbol{x}}}_3`\ 表示插入了触发器的图像块。输入图像块的查询（query）、键（key）和值（value）分别表示为\ :math:`q_i`\ 、\ :math:`k_i`\ 和\ :math:`v_i`\ ，其中\ :math:`i`\ 是图像块的索引。
在注意力模块中，注意力权重是通过对一个查询\ :math:`q_i`\ 和所有键的点积进行Softmax计算得到的。得到的注意力权重\ :math:`S^j_i`\ 是图像块\ :math:`i`\ 对于图像块\ :math:`j`\ 的注意力。可以通过最小化\ :math:`\mathcal{L}_{ATTN}^l`\ 来使得\ :math:`\hat{{\boldsymbol{x}}}_3`\ 获得更多的注意力，也通过最小化\ :math:`\mathcal{L}_{C E}`\ 优化\ :math:`\hat{{\boldsymbol{x}}}_3`\ 来攻击目标类别\ :math:`y_k`\ 。然而，同时实现这两个要求并不容易，因为这两个损失函数的梯度\ :math:`\nabla \mathcal{L}_{ATTN}=\nabla \lambda \cdot \sum_l \mathcal{L}_{ATTN}^l(\hat{{\boldsymbol{x}}}, m) / \nabla \hat{{\boldsymbol{x}}}`\ 和\ :math:`\nabla \mathcal{L}_{C E}=\nabla \mathcal{L}_{C E}\left(\hat{{\boldsymbol{x}}}, y_k\right) / \nabla \hat{{\boldsymbol{x}}}`
在训练过程中可能会相互冲突（符号相反）。为了解决这个问题，TrojViT采用了\ *梯度手术*\ （gradient
surgery） :cite:`yu2020gradient` 的方法：

.. math:: \nabla \mathcal{L}_{A T L}=\left\{\begin{array}{l}\nabla \mathcal{L}_{C E}+\nabla \mathcal{L}_{ATTN}, \text { if } \cos \left(\nabla \mathcal{L}_{C E}, \nabla \mathcal{L}_{ATTN}\right)>0 . \\\nabla \mathcal{L}_{C E}+\nabla \mathcal{L}_{ATTN}-\frac{\nabla \mathcal{L}_{C E} \cdot \nabla \mathcal{L}_{ATTN}}{\left\|\nabla \mathcal{L}_{C E}\right\|^2} \cdot \nabla \mathcal{L}_{C E}, \text { otherwise}\end{array}\right.
   :label: eq_trojvit_gradient_surgery

其中，\ :math:`cos(\cdot,\cdot)`\ 是\ :math:`cos`\ 相似度。

.. _fig_trojvit_attention_target_loss:

.. figure:: images/7_2_1_11_trojvit_attention_target_loss.png
   :width: 630px

   ATL损失计算过程举例 :cite:`zheng2023trojvit`



**（2）木马注入**\ ：TrojViT通过修改模型参数\ :math:`W`\ 向ViT模型中注入木马。TrojVit只需使用几个插入了图像块触发器的测试图像就可以修改ViT模型的重要参数，而不需要任何其他训练数据。TrojViT攻击对测试图像依赖性低，甚至可以随机选取。为了减轻木马注入对原模型参数的影响，TrojViT提出\ *调整参数蒸馏*\ （Tuned
Parameter
Distillation，TPD）技术，在注入木马的同时减少对模型参数的修改。首先，初始化选择一些需要调整的参数\ :math:`W_T`\ ，而\ :math:`W_T`\ 之外的参数在木马注入的过程中将会被冻住。TrojViT在实现的过程中直接选择了最后一个注意力层以及分类头中的参数进行注入。
根据式 :eq:`eq_trojvit_ATL` 和式
:eq:`eq_trojvit_gradient_surgery`
对\ :math:`W_T`\ 进行更新，在每一轮迭代的过程中，计算\ :math:`W_T`\ 中的每个神经元更新的绝对值，如果其更新的绝对值小于预设的阈值，则将该神经元从\ :math:`W_T`\ 中移除，不参与该轮以及后续的迭代更新。通过这种方法，可以逐步地减少需要更新的参数，从而以较少的位数修改来插入木马。

相比前面介绍的两个攻击方法，TrojViT对数据依赖更小。BadViT则需要使用少量原始训练数据，DBIA需要使用测试数据集生成代理数据集，相比之下，TrojViT仅通过随机抽样测试数据来进行后门攻击，具有更高的灵活性。

多触发器后门
~~~~~~~~~~~~

尽管后门攻击已经在很多研究中得到了广泛的探讨，但大多数研究都集中在单一触发器攻击上，即利用一种类型的触发器污染数据集。然而，现实世界的后门攻击可能要复杂得多，存在多个攻击者同时投毒一个数据的情况。研究者将这类攻击称为\ **多触发器后门攻击**\ （Multi-Trigger
Backdoor Attack，MTBA） :cite:`li2024multi` ，如
:numref:`fig_MTBA_trigger` 所示。

.. _fig_MTBA_trigger:

.. figure:: images/5.3/MTBA_Overview.png
   :width: 765px

   单触发器和多触发器后门攻击 :cite:`li2024multi`



**MTBA** 研究者主要探索使用了三种策略来实现多触发器的后门攻击：

-  **并行投毒**\ （Parallel
   Poisoning）：多个独立的攻击者使用不一样的触发器投毒同一个数据集的不同训练子集。
-  **顺序投毒**\ （Sequential
   Poisoning）：不同的攻击者在不同时间对同一数据集进行攻击，每次攻击都在新的数据子集上注入新的触发器，后面的触发器有一定概率会覆盖前面的触发器。
-  **混合触发器投毒**\ （Hybrid-Trigger
   Poisoning）：攻击者将多个触发器融合成一个超级复合触发器，以一个触发器达到多个触发器的效果。

基于上述三类多触发器后门攻击，研究者进行了200多次实验，覆盖10种触发器类型、4种投毒率、3种标签修改策略、2个数据集和4种DNN架构，总结出了下列几个主要现象：

-  **共存效应**\ （Coexisting
   Effect）：在10%的投毒率下，大多数触发器能够在单个模型中共存，并达到相当高的攻击成功率。
-  **覆盖效应**\ （Overwriting
   Effect）：在顺序攻击中，先前有效的触发器在新触发器注入后可能变得无效，表明了触发器之间可能存在覆盖效应。
-  **交叉激活效应**\ （Cross-activating
   Effect）：某些触发器能够被其他类型的触发器激活，表明它们之间存在一定程度的相似性或共享特征。
-  **复合触发器可以激活多种攻击**\ （Hybrid-trigger
   Attack）：混合触发器不仅本身能够实现高攻击成功率，还能在训练过程中交叉激活其某些组成成员的触发器。

.. _fig_labeling_mode:

.. figure:: images/5.3/labeling_mode.png
   :width: 630px

   三种标签修改策略示意图 :cite:`li2024multi`



此外，多攻击者的存在也会导致不同的标签修改方式，研究者探讨了下面三种常见的标签修改方式（见
:numref:`fig_labeling_mode` ）：

-  **All2One**\ ：这种策略将所有的后门样本标记为一个固定的后门标签。也就是说，无论原始样本属于哪个类别，被投毒后都会改为同一类错误标签，这模拟了所有攻击者对同一个后门目标感兴趣的场景。
-  **All2All**\ ：这种策略将后门样本的标签修改为下一类（在类别总数范围内循环）。例如，如果原始样本的标签是k，那么投毒后的样本标签将被改为\ :math:`(k+1)\%K`\ （假设总共有K个类别，\ :math:`\%`\ 为取模操作）。这种策略模拟不同的攻击者对不同类别感兴趣的场景。
-  **All2Random**\ ：这种策略将后门样本的标签随机修改为一个错误的类别。这种策略模拟了攻击者之间没有共同目标标签、随机攻击的情况，每个标签被选为后门目标标签的概率是相等的。

量化后门
~~~~~~~~

模型量化是一种通过降低模型参数的精度或者删除部分冗余参数的模型轻量化技术，其可以大幅降低模型的存储大小，提升其推理效率，使模型可以部署在内存和计算能力受限的IoT设备上。然而，近期的研究发现，模型的量化过程也可以被后门攻击，所植入的后门只有在量化后才会被激活。这一类攻击被称为\ **量化后门攻击**
:cite:`ma2023quantization` 。

.. _fig_PQ_trigger:

.. figure:: images/5.3/PQ_overview1.png
   :width: 855px

   PQ后门攻击示意图 :cite:`ma2023quantization`



**PQ后门攻击**
量化后门攻击发生在模型训练后，部署前。一个有代表性的方法是（Post-training
Quantization，PQ）后门攻击 :cite:`ma2023quantization`
，简称\ **PQ后门攻击**\ 。这是一种及其隐蔽的后门攻击方法，只有在对模型进行量化后，休眠的后门才会被唤醒。如
:numref:`fig_PQ_trigger` 所示，PQ后门攻击主要分为两个阶段：

-  **量化前后门植入**\ ：在全精度(32位浮点数)模型量化之前，攻击者预先在模型中植入一个休眠的后门，此后门不会影响模型的准确率，因此原则上可以绕过现有的所有后门检测方法。
-  **量化后后门激活**\ ：当模型通过量化框架进行量化后，预先安插的后门被激活，模型在有触发器的样本上输出后门类别。

具体来说，PQ后门攻击首先对一个高精度（32位浮点数）模型进行训练，让模型在干净和投毒样本上一起训练，完成后门植入。这一步模型训练所使用的损失函数为：

.. math:: \mathcal{L}_{bd} = \sum_{{\boldsymbol{x}} \in D} \mathcal{L}_{CE} \left(f_{bd}\left({\boldsymbol{x}}\right), y\right) + \sum_{{\boldsymbol{x}}_t \in D_t} \mathcal{L}_{CE} \left(f_{bd}\left({\boldsymbol{x}}_t\right), y_t\right)
   :label: Lbd

其中，\ :math:`\mathcal{L}_{CE}`\ 表示交叉熵分类损失函数，\ :math:`{\boldsymbol{x}}`\ 为干净样本，\ :math:`y`\ 为真实标签，\ :math:`{\boldsymbol{x}}_t`\ 表示含有触发器的样本，\ :math:`y_t`\ 为修改后的标签，\ :math:`D`\ 为干净训练数据子集，\ :math:`D_t`\ 为投毒数据子集，\ :math:`f_{bd}`\ 是全精度的后门模型。下一步是移除比较明显的后门，并保留隐蔽的后门，所使用的损失函数定义如下：

.. math:: \mathcal{L}_{rm} & = \mathcal{L}_3 + \mathcal{L}_4                                                                                                                       \\\mathcal{L}_3    & = \sum_{{\boldsymbol{x}} \in D} \mathcal{L}_{CE}\left(f_{rm}\left({\boldsymbol{x}}\right),y\right) + \sum_{{\boldsymbol{x}} \in D_c} \mathcal{L}_{CE}\left(f_{rm}\left({\boldsymbol{x}}_t\right),y\right) \\\mathcal{L}_4    & = \sum_{\tilde{\theta} \in  \tilde{\Theta}} \frac{1}{n}{\lVert \tilde{\theta}_{rm}-\tilde{\theta}_{bd} \rVert}_2^2 + {\lVert S_{rm}-S_{bd} \rVert}_2^2
   :label: eq_pq_l_rm

其中，\ :math:`f_{rm}`\ 表示正在接受后门移除的全精度模型（也就是上式中的\ :math:`f_{bd}`\ ），\ :math:`D_c`\ 为用来移除后门的少量干净样本（即防御数据集），\ :math:`\tilde{\theta}`\ 为量化参数，\ :math:`S`\ 是量化参数对应的缩放因子。其中，\ :math:`\mathcal{L}_3`\ 用来确保可以移除\ :math:`f_{bd}`\ 中比较明显的后门，\ :math:`\mathcal{L}_4`\ 第一项是为了在全精度模型后门被移除后，保留量化模型的后门效果，第二项确保\ :math:`\tilde{f}_{rm}`\ 的浮点32位“仿真推断”行为与\ :math:`\tilde{f}_{rm}`\ 保持一致。

实验结果表明，PQ后门攻击对于不同的后训练量化方法（即TensorFlow
Lite框架提供的全整数和动态范围量化）是有效的。在面对不同的后门检测时，PQ
后门攻击表现出很高的隐蔽性，在全精度模型中无法被检测到休眠的后门，而量化后的模型表现出接近100%的攻击成功率。量化后门攻击揭示了在大模型蓬勃发展的当下一种新的安全风险，预训练模型可以轻易将后门隐藏在高精度模型中，去投毒所有使用此模型的下游应用。

.. _sec_bd_defense:

后门防御
--------


针对前文介绍的后门攻击，研究者提出了一些有针对性的防御方法，目前这些方法大都探索解决ViT模型的图像块脆弱性缺陷，希望通过寻找、检测或阻断可疑的图像块来完成后门防御。本节将介绍三个有代表性的针对ViT模型的后门防御方法。

图像阻断
~~~~~~~~

研究发现，当使用GradRollOut（RollOut方法 :cite:`abnar2020quantifying`
的梯度版本，通过聚合Transformer的多层注意力来解释模型的预测）、GradCAM
:cite:`selvaraju2017grad`
等解释性算法对ViT的决策过程进行可视化时，会发现对模型预测有重大影响的图像区域往往与后门触发器有关。
如 :numref:`fig_Image_blocking`
所示，通过可视化热力图可以看出对ViT模型预测有重大影响的图像区域往往与植入的触发器相对应，而传统卷积神经网络则观察不到这种关联。基于此发现，研究人员提出了\ **图像阻断**
:cite:`subramanya2024closer`
防御方法，在训练阶段和测试阶段利用两种图像阻断技术来避免后门攻击，如
:numref:`fig_Image_blocking1` 所示。

.. _fig_Image_blocking1:

.. figure:: images/5.3/Image_blocking_1.png
   :width: 855px

   在测试期间，当一个触发器被粘贴到原图像上时，观察到ViT能够使用解释图突出显示触发器，而传统的卷积神经网络却不可以
   :cite:`subramanya2024closer` 。



**（1）测试时图像阻断**\ ：这是一种有效的即时防御策略，核心在于利用模型的解释能力来识别图像中可能含有后门触发器的区域。其使用如GradRollOut之类的解释性算法，获得一个热力图，直观地显示出对模型决策产生显著影响的区域。一旦发现潜在的触发器区域，就可以对这些区域进行遮挡或修改，以中和它们的影响。随后，将修改后的图像再次输入模型进行推理，此时由于后门触发器已被阻断，模型往往能够给出正确的预测。

**（2）训练时图像阻断**\ ：此方法在模型训练阶段就开始发挥作用，通过随机选择并阻断图像中的小块区域，迫使模型学习不依赖于这些区域的特征。这种阻断不仅包括简单地用黑色补丁替换图像区域，还包括一种称为\ *词元随机丢弃*\ （Token
Drop）的技术，它通过减少输入序列中的令牌数量，进一步促使模型关注图像的整体结构而非局部细节，让模型学会在不依赖特定图像区域的情况下进行预测。这种方法不仅优化了模型的训练过程，减少了计算量，还增强了模型对后门攻击的抵抗力。

.. _fig_Image_blocking:

.. figure:: images/5.3/Image_blocking.png
   :width: 758px

   图中展示了对ResNet50和ViT-Base执行阻塞防御的例子
   :cite:`subramanya2024closer`
   。其中，ViT可以成功地定位补丁，从而产生一个成功的防御。还可以观察到，一旦触发器被准确阻断，原始源预测就被恢复。结果是随机选择的，而不是精选的，所有例子的攻击都是成功的。



图像块处理
~~~~~~~~~~

ViT模型的后门攻击除了容易被可视化暴漏外，它对输入图像的随机变换也比较敏感，即在位置编码之前对图像块进行变换可以引发模型在干净和后门图像上的预测性能变化差异。
基于此，研究者提出\ **图像块处理**\ （Patch Processing）方法
:cite:`doan2023defending`
，其利用ViT模型对图像块变换的敏感性来检测后门投毒样本。
图像块处理方法包括以下几个步骤：

**步骤1（离线）**\ ：对于一小部分干净样本，应用\ *图像块随机丢弃*\ （PatchDrop）和\ *图像块随机打乱*\ （PatchShuffle）操作，对每个图像进行\ :math:`T`\ 次转换。对于每个样本\ :math:`{\boldsymbol{x}}`\ ，计算\ :math:`F_d\left({\boldsymbol{x}}\right) = \sum_{t=1}^{T}\mathbb{1}\{f\left({\boldsymbol{x}}\right) \neq f\left(R_d^{\left(t\right)}\left({\boldsymbol{x}}\right)\right)\}`\ 和\ :math:`F_s\left({\boldsymbol{x}}\right) = \sum_{t-1}^{T}\mathbb{1}\{F\left({\boldsymbol{x}}\right) \neq f\left(R_s^{t}\left({\boldsymbol{x}}\right)\right)\}`\ ，其中\ :math:`R_d^{\left(t\right)}`\ 和\ :math:`R_s^{\left(t\right)}`\ 分别表示随机应用PatchDrop和PatchShuffle。直观来说，\ :math:`F_d\left({\boldsymbol{x}}\right)`\ 和\ :math:`F_s\left({\boldsymbol{x}}\right)`\ 记录了在图像块处理后，对\ :math:`{\boldsymbol{x}}`\ 的预测标签变为其他标签的预期次数。

**步骤2（离线）**\ ：对给定在步骤1中创建的样本\ :math:`\{F_d\left({\boldsymbol{x}}_i\right)\}_{i=1,..,K}`\ 或\ :math:`\{F_s\left({\boldsymbol{x}}_i\right)\}_{i=1,..,K}`\ ，这里为PatchDrop和PatchShuffle分别设置阈值超参数\ :math:`k_d`\ 和\ :math:`k_s`\ ，选择在第\ :math:`n`\ 个百分位数的值以确保较小的误报率：

-  对于PatchDrop，通常选择一个较大的值，因为在随机丢弃操作后，后门攻击的成功率显著降低。
-  对于PatchShuffle，通常选择一个较小的值，因为在随机变换操作后，后门攻击的成功率并没有降低，而干净数据的准确性受到很大影响。

**步骤3（推理期间）**\ ：对于推理阶段的样本，随机应用\ :math:`T`\ 次PatchDrop和PatchShuffle，并分别记录标签变化的次数，即\ :math:`F_d\left({\boldsymbol{x}}\right)`\ 和\ :math:`F_s\left({\boldsymbol{x}}\right)`\ 。如果\ :math:`F_d\left({\boldsymbol{x}}\right)`\ 大于选定的PatchDrop阈值\ :math:`k_d`\ ，或者\ :math:`F_s\left({\boldsymbol{x}}\right)`\ 小于选定的PatchShuffle阈值\ :math:`k_s`\ ，则将样本标记为后门样本。否则，\ :math:`{\boldsymbol{x}}`\ 被标记为干净样本。

图像块处理防御方法只需要少量（少于1000个）干净样本用于阈值选择。此外，研究者展示了在没有干净样本时，此防御仍然有效，这使其应用范围更加广泛。

图像块搜索
~~~~~~~~~~

近期研究表明，自监督学习（SSL）也容易受到图像块后门投毒攻击，攻击者可以通过在一小部分数据（自监督学习中的数据都是未标记的）上添加后门触发器，使模型学习触发器与某个后门类比的对应关系。对此，一种直接的防御策略就是后门样本检测，在自监督学习的过程中发现那些异常的样本，并将它们从训练过程中移除。

一个有代表性的方法是\ **图像块搜索**\ （PatchSearch）
:cite:`tejankar2023defending`
，其通过单独训练一个分类器来识别有毒样本，并使用下面的三步防御方法（如
:numref:`fig_SSL` ）：

1. 首先，使用k-means聚类算法对训练数据集进行聚类，以便将视觉上相似的图像分在一组。由于投毒图像在表示空间中彼此接近，期望投毒图像会聚在一起。
2. 使用Grad-CAM等输入解释方法在图像中定位触发器候选位置。由于自监督学习中没有可用的监督分类器，这里使用基于聚类的分类权重。
3. 为每个图像分配一个有毒分数，衡量图像的中毒程度。这通过将候选触发器添加到随机图像上，并统计这些图像被分配到触发器所在聚类的数目来计算。
4. 通过一个迭代搜索过程，寻找毒性高的簇，并对簇中的图像进行评分。此过程通过随机采样、评分、移除（移除每次迭代中毒性最低的簇）和排名来找到高毒性样本。
5. 使用迭代搜索得到的高毒性样本来训练一个毒药分类器，用来准确地识别有毒样本。

.. _fig_SSL:

.. figure:: images/5.3/SSL.png
   :width: 810px

   图像块搜索检测示意图 :cite:`tejankar2023defending`



利用训练好的有毒样本分类模型，我们就可以在训练数据集中搜索并移除投毒样本，然后在清理后的训练集上重新训练得到一个干净的模型。PatchSearch是一个强大的工具，能显著提高模型在有毒数据上的鲁棒性，性能接近无后门攻击时的情况，展现出了一定的鲁棒学习优势。

.. _sec_model_steal:

模型抽取
--------


很多基座ViT模型都需要在海量数据上进行大规模的预训练，这个过程成本高昂，使得这些模型具有很高的价值。此外，在垂直领域对这些模型进行微调也需要大量专业数据，而这些专业数据是各领域比较难获取的宝贵资源，同样具有很高的商业价值。因此，视觉大模型及其应用成为模型抽取攻击者的主要目标。攻击者可以以很低的成本获取功能相似的替代模型并从中获利。在大模型时代，模型抽取攻击可能引发新的知识产权危机，因为企业和研究机构的模型技术可能会被泄露，从而迅速失去竞争优势。本小节将介绍两种针对视觉ViT模型的抽取攻击。

Cont-Steal攻击
~~~~~~~~~~~~~~

与传统抽取模型概率输出的方法不同，Cont-Steal攻击方法
:cite:`sha2023can`
首次尝试抽取图像编码器（encoder）和它编码的嵌入（embedding），也就是抽取特征抽取器和特征。一般的模型抽取攻击流程是，首先获取一个替代数据集，然后通过查询目标模型来给替代数据集打标签，最后在替代数据集上训练一个替代模型，攻击完毕。而对于抽取图像编码器来说，需要完成对替代编码器和目标编码器的特征对齐。
为了实现这一目标，Cont-Steal将对比学习与模型抽取结合，通过巧妙的定义相似对和不相似对，使替代编码器和目标编码器可以更好的进行表征对齐，已完成对编码器器成功抽取。下面将详细介绍Cont-Steal攻击的抽取步骤。

.. _fig_cont_stealing:

.. figure:: images/7.2_cont_stealing.png
   :width: 675px

   Cont-Steal攻击示意图 :cite:`sha2023can`



首先，构建一个\ *替代数据集*\ ，这个数据集中的样本可能是和受害者模型训练数据同分布的，当然也可以是不同分布的。之后，Cont-Steal使用数据增强对替代数据集中的样本进行增强，对于每一个样本都会增强后得到两个增强样本：\ :math:`\tilde{{\boldsymbol{x}}}_{i,s}`\ 和\ :math:`\tilde{{\boldsymbol{x}}}_{i,t}`\ 。这些样本可以组成\ :math:`N`\ 个样本对（\ :math:`\tilde{{\boldsymbol{x}}}_{i,s}`\ ，\ :math:`\tilde{{\boldsymbol{x}}}_{j,t}`\ ），同一个样本的不同增强版本构成正样本对（即\ :math:`i=j`\ ），不同样本的增强版本构成负样本对（即\ :math:`i \neq j`\ ）。
攻击者将样本对中的\ :math:`\tilde{{\boldsymbol{x}}}_{i,s}`\ 输入替代编码器\ :math:`E_S`\ ，将\ :math:`\tilde{{\boldsymbol{x}}}_{j,t}`\ 输入受害者（目标）编码器\ :math:`E_T`\ ，并通过下面的损失函数来训练替代模型\ :math:`E_S`\ ：

.. math:: \mathcal{L}_{ContSteal}=\frac{1}{N}\sum_{i=1}^{N}-\log \frac{D_{encoder}^+(i)}{D_{encoder}^-(i)+D_{self}^-(i)}
   :label: eq_cont_steal_5

其中，\ :math:`i`\ 是\ :math:`N`\ 个样本对的索引下标，\ :math:`D_{self}^-(\cdot)`\ 为表征自不相似度，\ :math:`D_{encoder}^-(\cdot)`\ 为负样本对表征相似度，\ :math:`D_{encoder}^+(\cdot)`\ 为正样本对表征相似度。这三个距离定义如下：

.. math:: D_{encoder}^+(i) = \operatorname{exp}(\operatorname{sim}(E_S(\tilde{{\boldsymbol{x}}}_{i,s}),E_T(\tilde{{\boldsymbol{x}}}_{i,t}))/\tau)
   :label: eq_cont_steal_1

.. math:: D_{encoder}^-(i) = \sum_{k=1}^{N} \operatorname{exp}(\operatorname{sim}(E_S(\tilde{{\boldsymbol{x}}}_{i,s}),E_T(\tilde{{\boldsymbol{x}}}_{k,t}))/\tau)
   :label: eq_cont_steal_2

.. math:: D_{self}^-(i) = \sum_{k=1}^{N} \mathbb{1}_{[k \neq i]}( \operatorname{exp}(\operatorname{sim}(E_S(\tilde{{\boldsymbol{x}}}_{i,s}),E_S(\tilde{{\boldsymbol{x}}}_{k,t}))/\tau))
   :label: eq_cont_steal_3

其中，\ :math:`E_S(\cdot)`\ 和\ :math:`E_T(\cdot)`\ 分别表示替代编码器和受害者编码器，\ :math:`\operatorname{sim}(u,v)=u^{T}v/\left \| u \right \| \left \| v \right \|`\ 代表\ :math:`u`\ 和\ :math:`v`\ 之间的余弦相似度，\ :math:`\tau`\ 是用于控制温度的超参数。
:math:`D_{encoder}^+(\cdot)`\ 拉进正样本对之间在两个编码器上的特征距离，同时\ :math:`D_{encoder}^-(\cdot)`\ 推远负样本对之间在两个编码器上的额特征距离；此外，\ :math:`D_{self}^-(\cdot)`\ 在替代编码器（不涉及目标编码器）上让负样本对不相似，从而完成对比学习在替代编码器器上的完整定义。
如 :numref:`fig_cont_stealing`
所示，Cont-Steal所设计的损失函数有助于正负样本之间更好区分，并互相为对方提供参考，从而更好的抽取模型的图像编码功能。
实验表明，这种攻击方式可以以很小的成本抽取到ViT、MAE和CLIP等图像编码器的功能，展示出一定的现实威胁。

.. _fig_RDA_stealing:

.. figure:: images/7.2_RDA_stealing.png
   :width: 751px

   RDA攻击示意图 :cite:`wu2023refine`



RAD攻击
~~~~~~~

Cont-Steal的攻击方式更像是一种知识蒸馏，需要在训练替代编码器的过程中对目标编码器进行持续不断的查询，所以会浪费很多查询。实际上，同一个样本的不同增强版本之间可以认为是存在一个特征中心的，增强的样本都围绕这个特征中心变化，而且这个特征中心可以通过目标编码器直接算出来，且在训练过程中保持不变。每个样本都有一个特征中心，这个特征中心被称为\ **嵌入原型**\ （embedding
prototype） :cite:`wu2023refine` 。基于这种思想，研究人员提出RAD
:cite:`wu2023refine`
攻击方法，进一步提升攻击效果和效率。RAD是三个关键技术的首字母简写：\ *精炼*\ （Refine）、\ *判别*\ （Discriminate）和\ *校准*\ （Aligning）。

“精炼”就是上面提到的利用嵌入原型来提升抽取效率的技术。具体来说，RAD攻击对每个样本\ :math:`{\boldsymbol{x}}_i \in D_S`\ 进行\ :math:`n`\ 次增强得到\ :math:`\{{\boldsymbol{x}}'_{i,t,c}\}_{c=1}^{n} = \{ {\boldsymbol{x}}'_{i,t,1},\cdots, {\boldsymbol{x}}'_{i,t,n}\}`\ ，将这些增强版本传入目标编码器\ :math:`E_T`\ 获得\ :math:`n`\ 个对应的特征编码：\ :math:`\{E_T({\boldsymbol{x}}'_{i,t,c})\}_{c=1}^{n} = \{ E_T({\boldsymbol{x}}'_{i,t,1}),\cdots, E_T({\boldsymbol{x}}'_{i,t,n})\}`\ 。
样本的嵌入原型就是这\ :math:`n`\ 特征编码的中心：

.. math:: p_{{\boldsymbol{x}}_i} = \frac{1}{n} \sum_{c=1}^{n}E_T({\boldsymbol{x}}'_{i,t,c}), \quad {\boldsymbol{x}}_i \in D_S
   :label: eq_RDA_steal_1

训练时，样本会被重新增强\ :math:`m`\ 次得到\ :math:`\{{\boldsymbol{x}}'_{i,s,q}\}_{q=1}^{m} = \{ {\boldsymbol{x}}'_{i,s,1},\cdots, {\boldsymbol{x}}'_{i,s,m}\}`\ ，之后输入到\ *替代模型*\ :math:`E_S`\ 中，获得对应的特征编码\ :math:`\{E_S({\boldsymbol{x}}'_{i,s,q})\}_{q=1}^{m} = \{ E_S({\boldsymbol{x}}'_{i,s,1}),\cdots, E_S({\boldsymbol{x}}'_{i,s,m})\}`\ 。
然后，使用下面的损失函数来训练替代模型：

.. math:: \mathcal{L} = \lambda_{1} \cdot \mathcal{L}_{D} + \lambda_{2} \cdot \mathcal{L}_{A}
   :label: eq_RDA_steal_8

其中，\ :math:`\mathcal{L}_{D}`\ 为判别损失，\ :math:`\mathcal{L}_{A}`\ 为对齐损失，\ :math:`\lambda_{1}`\ 和\ :math:`\lambda_{2}`\ 是用来调节损失函数中每部分权重的预设系数。其中，判别损失用来拉进一个样本的不同增强版本到其特征中心的距离，同时推远其他样本的增强版本到特征中心的距离；而对齐损失融合了\ *均方误差*\ 和\ *余弦相似度*\ 两个距离指标来加强样本到特征中心的对齐。

辨别损失\ :math:`\mathcal{L}_D`\ 定义如下：

.. math:: \mathcal{L}_{D} = - \frac{1}{N} \sum_{i}^{N}\log \frac{\mathcal{L}_{pos}({\boldsymbol{x}}_i)}{\mathcal{L}_{neg}({\boldsymbol{x}}_i)}
   :label: eq_RDA_steal_4

其中，\ :math:`\mathcal{L}_{pos}`\ 和\ :math:`\mathcal{L}_{neg}`\ 损失定义如下：

.. math:: \mathcal{L}_{pos} = \frac{1}{m} \sum_{q=1}^{m} \exp(\operatorname{sim}(E_S({\boldsymbol{x}}'_{i,s,q}), p_{{\boldsymbol{x}}_i})/\tau)
   :label: eq_RDA_steal_2

.. math:: \begin{aligned}\mathcal{L}_{neg} = & \frac{1}{m} \sum_{q=1}^{m} \sum_{k=1}^{N} \mathbb{1}_{[i \ne k]} (\exp(\operatorname{sim}(E_S({\boldsymbol{x}}'_{i,s,q}), p_{{\boldsymbol{x}}_k})/\tau) \\ + & \exp(\operatorname{sim}(E_S({\boldsymbol{x}}'_{i,s,q}), E_S({\boldsymbol{x}}'_{k,s,q})/\tau) )\end{aligned}
   :label: eq_RDA_steal_3

其中，\ :math:`\operatorname{sim}({\boldsymbol{u}},{\boldsymbol{v}})`\ 表示\ :math:`{\boldsymbol{u}}`\ 和\ :math:`{\boldsymbol{v}}`\ 之间的余弦相似度，\ :math:`\tau`\ 是温度参数。
对齐损失\ :math:`\mathcal{L}_A`\ 定义如下：

.. math:: \mathcal{L}_{A} = -\frac{1}{N} \sum_{i=1}^{N} \log \frac{\mathcal{L}'_{ang}({\boldsymbol{x}}_i)}{\mathcal{L}'_{amp}({\boldsymbol{x}}_i)}
   :label: eq_RDA_steal_7

其中，\ :math:`\mathcal{L}'_{amp}`\ 和\ :math:`\mathcal{L}'_{ang}`\ 损失项定义如下：

.. math:: \mathcal{L}'_{amp} = \frac{1}{m} \sum_{q=1}^{m}{\|E_S({\boldsymbol{x}}'_{i,s,q})-p_{{\boldsymbol{x}}_i} \|}^{2}
   :label: eq_RDA_steal_5

.. math:: \mathcal{L}'_{ang} = \frac{1}{m} \sum_{q=1}^{m} \operatorname{sim}(E_S({\boldsymbol{x}}'_{i,s,q}),p_{{\boldsymbol{x}}_i})
   :label: eq_RDA_steal_6

从上面判别损失和对齐损失的定义式不难看出，这两个损失项所涉及到模型只有替代模型\ :math:`E_S`\ ，并没有目标模型\ :math:`E_T`\ 。这也就是说，RAD训练替代模型的过程并不需要查询目标模型。如前文所述，这主要是得益于嵌入原型（即特征中心）的使用，相当于固定了目标编码器的监督信号，可大大减少查询次数。
实验表明，RDA方法比Cont-Steal更具威胁性，它只使用Cont-Steal十分之一的查询次数即可获得相当甚至更好的抽取性能。

目前针对视觉大模型的模型抽取攻击相对较少，相关的研究仍处于初级阶段。并且目前的研究重点关注在对视觉大模型编码器功能的抽取，其他方面的研究仍是空白。然而，可以看到，目前的攻击方法已经可以以很低的开销获得一个和受害者模型类似的替代模型。因而这种攻击具有很强的现实威胁，需要引起工业界和研究人员的注意，尽快提出一些有针对性的防御方法。在人工智能广泛部署的大形势下，一些应用领域中使用的视觉大模型需要更加谨慎地考虑模型的可信性问题，特别是对于一些敏感性高的应用，如医疗图像识别、人脸识别等，模型抽取攻击可能导致严重的隐私泄露和误导。因此，公司和研究机构在部署这些模型之前应该加强安全检查，确保其具有一定能力抵御模型抽取攻击。

.. _sec_deepfake:

深度伪造
--------


狭义来讲，深度伪造（Deepfake，可以分解为deep
learning和fake）特指基于深度学习模型的换脸技术；广义来讲，深度伪造是可以生成让人信以为真的虚假内容的人工智能机技术。
实际上，深度伪造技术也有一些积极的、具有创造性的应用，比如电影配音、“复活”历史人物、虚拟试衣、娱乐特效等。
但其一旦被滥用，所带来的危害性更大，比如制造虚假国家领导人讲话视频、传播虚假政治流言、利用虚假信息来操纵公众舆论、伪造明星视频等，侵犯了受害者的权益，造成了极其严重的负面社会影响，损害大众对人工智能技术的信任。所以，我们在研究深度生成技术的同时，需要加强监管和发展有效的检测技术。接下来，本章将从生成和检测两个方面出发，介绍几个有代表性的深度伪造以及检测方法。

生成
~~~~

深度伪造技术主要涉及面部交换，即将一个人的面部从源图像转移到目标图像，同时保留目标图像的姿势、表情、光照条件和其他属性。随着合成面部图像技术的快速发展，面部交换近年来引起了广泛关注。作为面部图像合成中最广泛使用的技术之一，它促进了各种实际应用，如肖像外观变换、用于面部分析的数据增强方法以及隐私保护。
面部交换方法可以分为基于3D模型和生成对抗网络的方法。基于3D模型的方法通常使用3D可变形模型，在源脸和目标脸之间建立密集的点对点对应关系。

**Face2Face** 一个经典的换脸算法是Face2Face :cite:`thies2016face`
，这是一个实时面部表情转移技术。Face2Face是一个3D方法，它通过脸部捕捉和再现来转移表情，使用密集的光度一致性测量来跟踪源视频和目标视频的面部表情,
后通过源和目标之间快速有效的变形传递来实现重演。
此方法从目标视频帧中检索并定位与表情最匹配的口型，并进行变形以产生准确的配合,
加上优化策略实现了低延迟的视频人脸再现，能够在源人脸作出对应表情动作之后马上以视频的形式再现到目标人脸上。此项技术可以用于电影后期制作、视频会议以及增强或改变在线视频中的表情。

.. _fig_5.6.1_face2face_pipeline:

.. figure:: images/5.6.1_face2face_pipeline.png
   :width: 720px

   Face2Face算法流程 :cite:`thies2016face`



如 :numref:`fig_5.6.1_face2face_pipeline`
所示，Face2Face算法主要包括以下几个步骤：

**（1）人脸参数化：**
首先在预处理步骤使用一种基于全局非刚性模型的捆绑方法，利用预先录制的一组训练帧来整体重建目标演员的面部形状特征3D模型。由于该预处理步骤在整套训练帧上全局进行，因此可以解决单目重建中常见的几何歧义问题。使用多线性主成分分析（multi-linear
PCA）技术对脸部进行参数化，前两维代表面部身份信息，即几何形状和皮肤反射率，第三维控制面部表情：

.. math:: M_{geo}(\boldsymbol{\alpha},\boldsymbol{\delta}) = {\boldsymbol{a}}_{id} + E_{id}\cdot\boldsymbol{\alpha} + E_{exp}\cdot\boldsymbol{\delta},

.. math:: M_{alb}(\boldsymbol{\beta}) = {\boldsymbol{a}}_{alb} + E_{alb}\cdot\boldsymbol{\beta}

在上面的公式中，假定形状和反射率在平均形状\ :math:`{\boldsymbol{a}}_{id}\in {\mathbb{R}}^{3n}`\ 和反射率\ :math:`{\boldsymbol{a}}_{alb}\in {\mathbb{R}}^{3n}`\ 附近呈现多元正太概率分布，给出了形状\ :math:`E_{id}\in {\mathbb{R}}^{3n\times80}`\ 、反射率\ :math:`E_{alb}\in {\mathbb{R}}^{3n\times80}`\ 、表情\ :math:`E_{exp}\in {\mathbb{R}}^{3n\times76}`\ 以及它们的标准差\ :math:`\sigma_{id} {\mathbb{R}}^{80}`\ 、\ :math:`\sigma_{alb} {\mathbb{R}}^{80}`\ 、\ :math:`\sigma_{exp} {\mathbb{R}}^{76}`\ 。构建出来的模型有53K个点，106K个面。合成图像\ :math:`C_{S}`\ 可以通过在\ *刚性模型变换*\ :math:`\Phi(v)`\ 和\ *全透视变换*\ :math:`\Pi(v)`
下对模型进行光栅化来生成。
其中的若干参数可以组成一个未知参数集，通过三个子项的联合变分优化（joint
variational
optimization）来得到，优化目标包括（1）\ *图像一致性*\ （Photo
Consistency），测量像素级的光度对准误差来量化合成图像对输入数据的解释程度；（2）\ *特征对齐*\ （Feature
Alignment），计算在 RGB
流中检测到的一组显著面部特征点对之间的特征相似性；（3）\ *统计正则*\ （Statistical
Regularization），基于正态分布人群的假设来强制参数在统计上接近均值。

**（2）表情迁移：**
为了表情的实时迁移并在迁移过程中保持演员的独特性，Face2Face提出一种\ *子空间变形迁移*\ （sub-space
deformation
transfer）技术，将源演员的表情变化传递到目标演员，同时保留每个演员表情的个性化特征。假设源身份为\ :math:`\boldsymbol{\alpha}^S`\ 和目标身份为\ :math:`\boldsymbol{\alpha}^T`\ ，传递过程以源身份的中性表情\ :math:`\boldsymbol{\delta}_{N}^S`\ 和目标身份的中性表情\ :math:`\boldsymbol{\delta}_{N}^T`\ 作为输入，输出是迁移后的表情\ :math:`\boldsymbol{\delta}^T`\ 。首先，计算源变形梯度\ :math:`A_{i}\in {\mathbb{R}}^{3\times 3}`\ ，将源演员的三角片从中性（neutral）转换为变形（deformed）状态。然后，基于未变形状态\ :math:`v_{i}=M_i(\boldsymbol{\alpha}^T,\boldsymbol{\delta}_{N}^T)`\ ，通过最小二乘法计算得到变形目标状态\ :math:`\hat{v}_{i}`\ ，此优化问题可形式表示为：

.. math:: E(\boldsymbol{\delta}^T) = \|A\boldsymbol{\delta}^T-\boldsymbol{b}\|^2_{2}

其中，矩阵\ :math:`A`\ 是常数矩阵，包含了投影到表情子空间的模板网格的边缘信息，\ :math:`\boldsymbol{b}`\ 是在中性空间目标的边缘信息。上式的最小值可以通过求解相应的正交方程（normal
equations）来获得。由于系统矩阵是常数，所以可以使用\ *奇异值分解* (SVD)
预先计算其伪逆，这样能大幅度减少优化问题的维度，从而实现快速的实时传递效率。

**（3）嘴型检索：**
在表情迁移后，仍然需要对嘴型进行最后的匹配和调整，以使其看起来更加真实自然。Face2Face
方法引入了一种新的基于图像的嘴部合成方法，通过从目标演员视频序列中检索并变形（warp）最匹配的嘴部图像。
该方法基于一种“帧到簇”（Frame-to-Cluster）的匹配策略和特征相似性度量，找到包含最佳目标嘴的帧。其使用几何和光度特征（包括旋转、表情参数、关键点等信息）来表示视频帧，并在这个空间中检索最匹配的目标嘴部帧。在此过程中，研究者将目标演员的人脸帧聚类为10个簇，然后通过与这些簇的代表帧（距离簇内其他帧最近的帧）比较，检索得到最匹配的嘴型帧。此外，为了保证时序上的连贯性，研究者使用一个\ *密集外观图*\ （dense
appearance
graph）强制让检索到的嘴型帧与上一步的嘴型帧和目标嘴型帧之间都相似（以保证连续性）。
最后，在光流对齐后，对像素级空间进行 alpha
混合，并进行照明校正，将原始视频帧、照明校正后的投影嘴部帧和渲染的面部模型融合在一起，完成最终的换脸。

.. _fig_5.6.1_fsgan_pipeline:

.. figure:: images/5.6.1_fsgan_pipeline.png
   :width: 900px

   FSGAN算法流程 :cite:`nirkin2019fsgan`



**FSGAN**
在Face2Face之后又出现了很多效果很好的换脸算法，比如\ **FSGAN**\ （Face
Swapping GAN） :cite:`nirkin2019fsgan`
。相比Face2Face，FSGAN是一个基于GAN的纯视觉方法，只对图片像素进行操作和生成。FSGAN是一个主体无关的神经网络模型，它可以应用于不同主体的脸部，而不需要针对特定主体进行训练。其主要思想是，先将源图人脸的角度转换到与目标人脸相同，同时生成分割脸部、头发和背景的掩码，然后再将源图的脸部和目标图的头发背景进行融合，最终达到换脸效果。
FSGAN的算法流程如 :numref:`fig_5.6.1_fsgan_pipeline`
所示，其三个主要步骤都是依靠生成对抗网络来完成的。
FSGAN所使用的模型包含四个生成器，共有四个生成器Gr、Gs、Gc和Gb，其中Gr的作用是用源图的脸部生成对应目标脸部的姿势和表情，Gs用来得到目标脸部的头发、脸部和背景的分割，Gc用来把Gr生成的脸部与目标图脸部相比缺失的部分补齐，最后Gb的作用是将补齐的人脸与目标图进行融合。

首先，对于第一个生成器Gr，给定一个图像\ :math:`I`\ 和一个脸部的热力图表示\ :math:`H(p)`\ ，用\ :math:`F_{s}`\ 和\ :math:`F_{t}`\ 来分别表示源图脸部和目标图脸部，然后通过对3D关键点插值得到旋转角度后的源图以及对应的掩码：

.. math:: I_ {r_ {j}}  ,  S_ {r_ {j}} = G_ {r}  (  I_ {r_{j-1}} ; H(p_{j})),

.. math:: I_ {r_ {0}}=I_{s}

其中，\ :math:`1\leq j \leq n`\ ，\ :math:`H(p_{j})`\ 表示不同转动角度下的热力图，\ :math:`I_ {r_ {j}}`\ 表示生成的图像，\ :math:`S_ {r_ {j}}`\ 表示生成的掩码。

对于第二个生成器Gs，其输入是一张图片，输出一个对背景、人脸和头发进行编码的3通道分割掩码。对于遮挡部分的人脸，使用第三个生成器Gc来进行人脸补齐，Gc渲染面部图像Fs，使得到的面部渲染Ir覆盖Ft的整个分割掩模St，从而解决这种遮挡。最后，使用第四个生成器Gb进行人脸的融合。
这四个生成器需要基于三个损失函数进行训练：（1）特定域感知损失，（2）重建损失，（3）对抗损失。下面详细介绍这三个损失函数。

**（1）特定域感知损失**\ ：为了捕捉精细的面部细节，FSGAN使用下面的感知损失：

.. math:: \mathcal{L}_{perc}({\boldsymbol{x}}, y) = \sum_{i=1}^{n} \frac{1}{C_i H_i W_i} \left\| f_i({\boldsymbol{x}}) - f_i(y) \right\|_1

其中，\ :math:`f_i`\ 表示预训练的特征提取网络第i层的特征图，这里的预训练网络使用的是在人脸识别和人脸属性分类数据集上训练得到的VGG19。上面损失中\ :math:`L_1`\ 距离的使用可以帮助捕获高频细节。

**（2）重建损失**\ ：用感知损失捕获人脸的细节之后，单用一个损失函数通常会产生颜色步准确的图像。所以，需要使用一个像素级的损失函数\ :math:`\mathcal{L}_{pixel}`\ 来解决这个问题：

.. math:: \mathcal{L}_{pixel}({\boldsymbol{x}}, y) = \left\| {\boldsymbol{x}} - y \right\|_1

上述两个损失共同组成了一个重建损失，形式化表示如下：

.. math:: \mathcal{L}_{rec}({\boldsymbol{x}}, y) = \lambda_{perc} \mathcal{L}_{perc}({\boldsymbol{x}}, y) + \lambda_{pixel} \mathcal{L}_{pixel}({\boldsymbol{x}}, y)

**（3）对抗损失**\ ：这是生成对抗网络必备的训练损失。对于一个生成器\ :math:`G`\ 和多个判别器\ :math:`\{D_1, ..., D_n\}`\ ，对抗损失函数定义如下：

.. math:: \mathcal{L}_{adv}(G, D) = \min_{G} \max_{D_1,...,D_n} \sum_{i=1}^{n} \mathcal{L}_{GAN}(G, D_i)

其中，针对单个生成器\ :math:`G`\ 和多个判别器\ :math:`D_i`\ 的\ :math:`\mathcal{L}_{GAN}`\ 损失函数定义如下:

.. math:: \mathcal{L}_{GAN}(G, D_i) = \mathbb{\mathbb{E}}_{({\boldsymbol{x}},y)}[\log D_i({\boldsymbol{x}}, y)] + \mathbb{\mathbb{E}}_{{\boldsymbol{x}}}[\log (1 - D_I({\boldsymbol{x}}, G({\boldsymbol{x}})))]

四个生成器Gr、Gs、Gc和Gb的训练过程如下。首先，对于Gr生成器的部分，定义并使用\ *逐步一致性损失*\ （用于在小步骤中逐步训练人脸重构，超参数为\ :math:`\lambda_{stepwise}`\ ）进行训练:

.. math:: \mathcal{L}(G_r) = \lambda_{stepwise} \mathcal{L}_{rec}(\tilde{I}_{r_{n}}, \tilde{I}_t)+ \lambda_{rec} \mathcal{L}_{rec}(\tilde{I}_r, \tilde{I}_t)+ \lambda_{adv} \mathcal{L}_{adv}+ \lambda_{seg} \mathcal{L}_{pixel}(S_r, S_t)

其中，对于一个（\ :math:`I_s,I_t`\ ）对，\ :math:`I_{r_n}`\ 是\ :math:`I_s`\ 经过\ :math:`n`\ 次迭代后生成的图片，在用\ :math:`S_t`\ 和\ :math:`S_{r_j}`\ 作为分割掩码来去掉背景的情况下，\ :math:`I_{r_n}`\ 和\ :math:`I_t`\ 应该是一样的图片。

对于Gs，使用标准的交叉熵损失函数和来自Gr生成器的指导信息：

.. math:: \mathcal{L}(G_s) = \mathcal{L}_{CE} + \lambda_{reenactment} \mathcal{L}_{pixel}(S_t, S^t_r)

其中，\ :math:`S^t_r`\ 是来自Gr生成的分割掩码。

生成器Gc通过重建和对抗损失进行训练：

.. math:: \mathcal{L}(G_c) = \lambda_{rec} \mathcal{L}_{rec}(I_c, \tilde{I}_t) + \lambda_{adv} \mathcal{L}_{adv}

用来进行人脸融合的生成器Gb使用泊松融合损失进行训练。首先定义泊松
融合优化：

.. math:: P(I_t; I^t_r, S_t) = \arg\min_f \left\|\nabla f - \nabla I^t_r\right\|_2^2,\text{s.t. } f(i, j) = I_t(i, j), \quad \forall S_t(i, j) = 0

那么泊松损失函数为：

.. math:: \mathcal{L}(G_b) = \lambda_{rec} \mathcal{L}_{rec}(G_b(I_t; I^t_r, S_t), P(I_t; I^t_r, S_t)) + \lambda_{adv} \mathcal{L}_{adv}

在Face2Face和FSGAN的基础上，近年来人脸交换技术不断发展，涌现了大量新的方法。近期，研究者提出了更加先进的人脸交换算法，而FaceSwapper就是其中之一，它采用了一次性的渐进式交换方式，是一种基于GAN的伪造方法。

**FaceSwapper** 尽管面部交换技术取得了显著进展，但仍然存在诸多挑战。
首先，为了实现逼真的面部交换，现有方法通常需要来自同一身份的许多图像进行外观建模。这些方法的一个缺点是它们的泛化能力差，难以适应任意面孔。
其次，完全分离身份信息和属性信息是困难的，这导致交换面部的可控性较差。
此外，先前的方法在利用语义信息方面受到了一定限制。
因此，必须利用大量图像来训练基于注意力或细化模型的面部交换模型。
与之前方法不同，FaceSwapper :cite:`Li2024faceswapper`
专注于一个更有挑战性的任务，即\ *一次性渐进面部交换*\ ，在训练和测试中只给出源身份和目标身份各一张面部图像，能够很好地泛化和适应任意面孔。

.. _fig_5.6.1_faceswapper_pipeline:

.. figure:: images/5.6.1_faceswapper_pipeline.png
   :width: 900px

   FaceSwapper算法流程 :cite:`Li2024faceswapper`



FaceSwapper同样也是一个基于生成对抗网络的方法。如
:numref:`fig_5.6.1_faceswapper_pipeline`
所示，FaceSwapper由两个核心模块组成：\ *解耦表示模块*\ （Disentangled
Representation Module，DRM）和\ *语义引导融合模块*\ （Semantic-guided
Fusion Module，SFM）。
解耦表示模块将人脸图片的属性（姿态、表情、灯光和背景）和身份信息分离，需要用到两个编码器，一个用来提取人脸的身份信息，另一个用来提取人脸的属性信息。这种信息分离是实现渐进式面部交换的基础，分离的属性和身份信息将会输入语义引导融合模块进行换脸图像的生成。
而语义引导融合模块则利用面部语义信息（即定义面部区域的掩码信息）来指导属性信息和身份信息的融合，通过一些特殊的网络结构来完成最终图像的生成。

*解耦表示模块*\ 包含两个编码器，属性编码器\ :math:`E_{attr}`\ 和身份编码器\ :math:`E_{id}`\ 。属性编码器负责提取人脸图像中的属性信息，如姿态、表情、光照和背景等；身份编码器比较灵活，用于提取和学习人脸图像中的身份信息。在网络结构上，由于身份信息可以直接用向量表示，而属性信息包含大量与身份无关的信息，难以用向量表示，因此由多层特征图组成的残差瓶颈块被附加在属性编码器的末尾以表示属性信息。具体来说，属性编码器后连接5个下采样残差块和2个残差瓶颈块，身份编码器后连接有6个下采样残差块，然后在最后附加一个卷积层和一个全连接层。

.. _fig_5.6.1_SFM_module:

.. figure:: images/5.6.1_SFM_module.png
   :width: 720px

   语义引导融合模块 :cite:`Li2024faceswapper`



*语义引导融合模块*\ 如 :numref:`fig_5.6.1_SFM_module`
所示，其只包含一个语义引导融合的解码器\ :math:`G_{f}`\ 。其将网络前面的编码器输出作为输入，并生成图像作为输出。具体来说，属性编码器\ :math:`E_{attr}`\ 会产生\ :math:`E_{attr}(I_{{\boldsymbol{x}}})`\ 和\ :math:`E_{attr}(I_{y})`\ 的输出，身份编码器\ :math:`E_{id}`\ 会对应产生\ :math:`E_{id}(I_{{\boldsymbol{x}}})`\ 和\ :math:`E_{id}(I_{y})`\ 的输出,语义引导融合的解码器\ :math:`G_{f}`\ 将\ :math:`E_{id}(I_{{\boldsymbol{x}}})`\ 和\ :math:`E_{attr}(I_{y})`\ 作为输入，来产生最后的换脸图像\ :math:`I_{{\boldsymbol{x}}\to y}`\ 。在这个模块中，使用了BiSeNet
:cite:`yu2018bisenet`
的语义分割方法来将人脸的面部和其他背景分割开来，生成一个语义掩码，这样就将语义信息加入到模型中了。

语义引导融合模块的结构包含2个瓶颈块和5个下采样语义引导脸部交换模块。从
:numref:`fig_5.6.1_SFM_module`
中可以看到，语义引导模块就是在标准残差块上将归一化层替换成了\ *语义引导去归一化层*\ （Semantic-guided
Denormalization
Layer，SDL），在SDL中使用实例归一化，可以防止均值和协方差偏移，并简化学习过程。因为属性编码器提供的脸部空间信息是受到限制的，仅能够获得外表信息而无法获得姿态和表情信息，所以在这个模块中同时加入了脸部关键点来辅助解码器捕获空间信息。

:numref:`fig_5.6.1_SFM_module`
中下面是SDL的详细结构，其中\ :math:`S^i`\ 是分割掩码，\ :math:`n^i`\ 是前一层传来的特征图，\ :math:`E_{id}`\ 是身份编码器传来的特征向量，而\ :math:`L^i`\ 就是脸部的关键点数据。首先将特征图与掩码做点乘，然后再用点积与跳连的方式将身份信息和脸部空间信息引入模型，就得到了SDL层的输出\ :math:`n^i_{out}`\ ，即：

.. math:: n_{out}^i = {n^i} \otimes \left( {1 - {S^i}} \right) + {p^i}

其中，

.. math:: {p^i} = {\phi ^i}\left( {{L^i}} \right) \otimes {m^i} + {\varphi ^i}\left( {{L^i}} \right),{m^i} = {\alpha ^i}\left( {{E_{id}\left( {{I_x}} \right)}} \right) \odot {\bar n^i} + {\beta ^i}\left( {{E_{id}\left( {{I_x}} \right)}} \right)

在这里\ :math:`p^i`\ 是去归一化后的激活值，而\ :math:`\phi ^i\left( {{L^i}} \right)`\ 和\ :math:`\varphi ^i\left( {{L^i}} \right)`
是学习到的缩放尺度和偏差调制参数。

FaceSwapper方法中用到了\ *身份保存损失*\ （以保留源图像的个性化特征）、\ *属性保存损失*\ （以维护目标图像的属性）、\ *重建损失*\ （确保编码器和解码器彼此可逆）以及\ *对抗损失*\ （鼓励合成高度逼真的图像）。
对于\ *身份保存损失*\ ，采用最小化特征空间中\ :math:`I_{{\boldsymbol{x}}\to y}`\ 和\ :math:`I_{{\boldsymbol{x}}}`\ 之间的距离，从而嵌入个性化的身份相关信息。对于\ *属性保留损失*\ ，利用
SFM
的多层特征图来表示属性，其中有一个组件称为属性提取器，要最小化\ :math:`I_{{\boldsymbol{x}}\to y}`\ 和\ :math:`I_{y}`\ 之间属性特征的距离。对于\ *重建损失*\ ，采用的是自编码器的方式，通过最小化重建原始输入人脸和生成人脸之间的差异来约束网络生成真实且有意义的人脸图像。对于\ *对抗损失*\ ，为了使图像与真实面部图像难以区分，鉴别器网络\ :math:`D`\ 将以样本对作为输入，其中正样本对为交换过的面部图像与目标面部的关键点图像，负样本对为真实面部图像与其对应的关键点图像。鉴别器\ :math:`D`\ 不仅可以引导生成器生成逼真的面部图像，还可以促使生成的图像包含与目标图像一样的面部关键点。

检测
~~~~

.. _fig_8.2.2_deepfake detection:

.. figure:: images/8.2.2_deepfake_detection.png
   :width: 810px

   深度伪造检测的一般流程 :cite:`masood2023deepfakes`



**传统方法**
深度伪造检测就是判断一个视频是否是伪造的，可以理解成是一个二分类任务，大多数检测算法遵循如
:numref:`fig_8.2.2_deepfake detection`
所示的流程。首先对视频进行预处理并提取特征，然后将特征输入分类器得到判断结果。大多数检测方法都采用手工或基于深度学习的方法来提取特征，少部分方法使用两者结合的方式。很多检测方法利用多种模态（如音频和视觉信号）构建更有效的检测表征。

基于手工特征的检测方法可以使用\ *加速鲁棒特征*\ （SURF）描述符进行特征提取来检测交换面部的技术，然后在提取的特征上训练一个简单的分类器（如SVM）
进行分类。更先进的方式是使用预训练的深度神经网络进行特征提取，如ResNet
和
VGG等，而且最好是在类似的视频上预训练的模型，否则在通用数据集如ImageNet上训练的模型往往不具备人脸特征提取能力。特征提取时可以先用dlib工具提取人脸的关键点，然后基于关键点进行特征提取。基于特征工程的检测方法可解释性比较好，但是相比端到端的方法来说性能往往比较差。

**多注意力深伪检测**\ （Multi-attentional Deepfake Detection，MADD）
:cite:`Zhao2021Multi-attentionalDetection`
是一个端到端的检测方法，其相比起前面的算法在准确度和稳定性上都有了很大的提升。MADD的核心思想是把深伪检测看作是一个细粒度的二分类任务，并使用多注意力机制去捕获浅层的纹理特征。

.. _fig_5.6.2_mutiattention_pipeline:

.. figure:: images/5.6.2_mutiattention_pipeline.png
   :width: 810px

   多注意力深伪检测算法流程 :cite:`Zhao2021Multi-attentionalDetection`



如 :numref:`fig_5.6.2_mutiattention_pipeline`
所示，MADD具有三个关键组成部分：

-  **纹理增强模块**\ ：此模块对来自特定层的特征使用局部平均池化操作，然后通过图像块划分进行下采样，得到池化后的特征图
   :math:`D`\ ；将输入和\ :math:`D`\ 做差，得到表示纹理信息的特征级残差，再通过一个密集连接的卷积模块来增强这个残差，输出纹理特征图。
-  **注意力模块**\ ：此模块将网络中的中间结果作为输入，进行一个1*1的卷积、一层批归一化、一层ReLU，输出\ :math:`k`\ 个注意力图，每个都与一个具体的区域相联系。
-  **双线性注意力池化**\ ：此操作融合前面的特征信息，将注意力图和浅层纹理特征做点积，得到一个纹理特征矩阵；与此同时，将骨干上的深层特征与注意力图做类似的点积得到全局特征，最后一起输入分类器中得到分类结果。

但是，由于缺乏细粒度的标签，训练多注意力网络可能会容易陷入网络退化状态。
具体来说，不同的注意力图往往会关注相同的区域，这不利于捕捉给定输入的丰富信息。
此外，对于不同的输入图像，我们希望每个注意力图都定位在固定的语义区域，所以在这个方法中引入了\ *区域独立性损失*\ （Regional
Independence Loss）：

.. math:: \mathcal{L}_{RIL} = \sum_{i=1}^{B}\sum_{j=1}^{M} \max\left(\left\| V_j^i - {\boldsymbol{c}}_j^t \right\|_2^2 - m_{in}(y_i), 0\right)_+ \\+ \sum_{i,j \in (M,M), \ i \neq j} \max\left( m_{out} - \left\| {\boldsymbol{c}}_i^t - {\boldsymbol{c}}_j^t \right\|_2^2, 0\right)

其中，\ :math:`V \in {\mathbb{R}}^{M\times N}`\ 是在神经网络特定层抽取的语义特征向量，\ :math:`B`\ 是批大小，\ :math:`M`\ 是特征图的数量，\ :math:`m_{in}`\ 表示特征和其特征中心的间隔，当\ :math:`y_i`\ 为不同的值时，\ :math:`m_{in}`\ 也会设定不同的值。\ :math:`m_{out}`\ 表示特征中心之间的距离。这个公式的前半部分是为了让类内距离最小，后半部分是为了让类间距离最大。\ :math:`{\boldsymbol{c}} \in {\mathbb{R}}^{M\times N}`\ 是\ :math:`V`\ 的特征中心，会在每一步中进行如下的迭代更新：

.. math:: {\boldsymbol{c}}^t = {\boldsymbol{c}}^{t-1} - \alpha \left( {\boldsymbol{c}}^{t-1} - \frac{1}{B} \sum_{i=1}^{B} V^i \right)

最后，该方法的整体损失函数为\ :math:`\mathcal{L} = \lambda_1\mathcal{L}_{CE} + \lambda_2\mathcal{L}_{RIL}`\ 。

MADD方法的关键创新是将深伪检测问题转成一个细粒度分类问题求解，并融入了注意力对浅层特征的提取方法，最后达到一个很好的鉴别效果。

**F3Net**
该方法的主要思想是使用频域的信息做为特征来对虚假图像进行分类。之所以利用频率信息来挖掘伪造模式，是因为频率提供了一种互补的视角，可以很好地描述细微的伪造痕迹或压缩错误。
F3Net :cite:`Qian2020ThinkingInFrequency`
使用两种特征：一种是高频分解的图像分量；另一种是局部频率统计信息。前者的目的是学习伪造模式中不易被发现的痕迹，后者目的是从局部统计信息中提取高频语义去描述真假脸部的频率统计信息之间的差异。

.. _fig_5.6.2_f3net_pipeline:

.. figure:: images/5.6.2_f3net_pipeline.png
   :width: 810px

   F3Net算法流程 :cite:`Qian2020ThinkingInFrequency`



如 :numref:`fig_5.6.2_f3net_pipeline` 所示，F3Net主要由两个分支组成：

**（1）频率感知分解**\ （Frequency-Aware
Decomposition，FAD）：FAD根据一组可学习的频率滤波器，自适应地将输入图像在频率域中进行分割，分解出的频率组分可以逆变换回空间域，从而得到一系列频率感知的图像。这些图像沿通道轴堆叠，然后输入到卷积神经网络中挖掘伪造模式：

.. math:: \hat{y}_i = {\mathcal{D}}^{-1}\left\{ {\mathcal{D}}({\boldsymbol{x}}) \odot \left[ f^i_{base} + \sigma(f^i_{w}) \right] \right\}, \quad i = \{1, \ldots, N\}

其中，\ :math:`f^i_{w}`\ 是可学习的频率滤波器，\ :math:`{\mathcal{D}}({\boldsymbol{x}})`\ 是对\ :math:`{\boldsymbol{x}}`\ 做DCT变换将其转换到频率域，最后分解后转换到空间域。

**（2）局部频率统计**\ （Local Frequency Statistics，LFS）：LFS在输入
RGB 图像上应用滑动窗口 DCT (SWDCT)（即在图像的滑动窗口上密集地进行 DCT
变换），以提取局部化的频率响应。然后，在一系列可学习的频段上对平均频率响应进行计数。这些频率统计信息重新组装成一个多通道的空间映射图：

.. math:: q_i = \log_{10} \left\| {\mathcal{D}}(\mathbf{p}) \odot \left[ h^i_{\text{base}} + \sigma(h^i_{w}) \right] \right\|_1, \quad i = \{1, \ldots, M\}

其中，\ :math:`h^i_{w}`\ 是可学习的滤波器，对一个窗口\ :math:`p`\ ，局部频率统计\ :math:`q`\ 最后会转换为一个\ :math:`1 \times 1 \times M`\ 的向量，然后从所有窗口收集的这些统计向量重新组装成一个矩阵，其空间大小是输入图像的降采样大小，其通道数等于\ :math:`M`\ 。该映射图与输入图像具有相同的布局，用于检测细节异常的频率分布。在成套的频段内计算统计量可以减少统计表示的冗余，同时产生更平滑的分布，避免异常值的干扰。

最后，通过跨注意力融合模块（cross-attention fusion
module）对来自两个分支的数据进行融合，使用交叉注意力机制得到注意力图，然后与两个特征图分别做点积，最后再加上特征图原图输入到分类器中。

F3Net的核心创新点是提出了一种考虑了频域信息的深伪检测框架，在低精度的图片上检测效果一骑绝尘，在高质量的图片上的检测能力也不落下风，为深度伪造监测提供了新的思路。

**Face X-ray**
这是一个经典的人脸伪造检测算法。鉴于大多数人脸修改算法的最后一步都是将更改后的面部融合到现有背景图像中，Face
X-ray :cite:`Li2020FaceX-Ray`
提出通过检测伪造图像的融合边界异常来检测面部修改。此方法只假设换脸算法存在人脸融合这一步，并不依赖于具体的面部修改算法或者换脸造成的面部伪影信息。同时，该方法的训练比较灵活，不一定需要最先进的面部修改算法和它生成的修改样例，可以基于一般的面部修改算法进行。

.. _fig_5.6.2_facexray_pipeline:

.. figure:: images/5.6.2_facexray_pipeline.png
   :width: 810px

   Face X-ray算法流程 :cite:`Li2020FaceX-Ray`



此前检测方法主要把注意力集在“分类”，在混合了伪造和真实视频的数据集上训练一个逐帧的二分类模型。与此前方法不同，Face
X-ray主要关注融合边界的“定位”。每张图像都有自己独特的标记或基础统计属性，因此，可以利用跨边界的基础图像统计指标的不一致性来定位融合边界，从而检测伪造的人脸图像，具体流程如
:numref:`fig_5.6.2_facexray_pipeline` 所示。

首先定义检测问题。给定一个人脸图像\ :math:`I`\ ，Face
X-ray要判断它是否是由\ :math:`I_F`\ 和\ :math:`I_B`\ 生成的伪造图像\ :math:`I_M`\ ：

.. math:: I_M = M \circ I_F + (1 - M) \circ I_B
   :label: eq_Face X-ray

其中，\ :math:`\circ`\ 表示元素积，\ :math:`I_F`\ 表示提供面部属性的前景图像，\ :math:`I_B`\ 表示提供背景的图像，\ :math:`M`\ 是区分替换区域的掩码。Face
X-ray的检测结果是一个图像（矩阵）\ :math:`B`\ ，如果输入是伪造的图像，则\ :math:`B`\ 将显示融合边界；如果输入是真实图像，则\ :math:`B`\ 的所有像素都为零，形式化表示为：

.. math:: B_{i,j} = 4 \cdot M_{i,j} \cdot (1 - M_{i,j})

当结果矩阵\ :math:`B`\ 为全0时，掩码矩阵\ :math:`M`\ 是一个全0或全1的矩阵，用于分隔前景图像区域。结果矩阵\ :math:`B`\ 里的元素最大取值为0.25，此时对应的\ :math:`M`\ 元素为0.5。

对于训练数据的生成，由于Face
X-ray只关心融合边界，因此完全可以通过融合两张真实图像来创建训练数据。首先，选定两张真实照片，然后生成一个随机掩码来分隔处理区域，最后遵循公式
:eq:`eq_Face X-ray` 来生成融合图像，以及生成边界。在实践中，Face
X-ray会随训练过程动态生成标记数据。基于此训练数据，可以训练一个基于卷积神经网络的框架（表示为\ :math:`NN_b`\ ）来生成结果矩阵。此框架以待检测图像\ :math:`I`\ 为输入，输出\ :math:`\hat{B} = NN_b(I)`\ ；此外还有一个分类头（表示为\ :math:`NN_c`\ ）输出预测的概率：\ :math:`\hat{c} = NN_c(\hat{B})`\ 。分类头\ :math:`NN_c`\ 由全局平均池化层、全连接层和
Softmax 激活层按顺序组成。
在训练期间，可以对这两个输出头应用下面的损失函数进行训练：

.. math:: \mathcal{L} = λ\mathcal{L}_{b} + \mathcal{L}_{c}

其中，\ :math:`\mathcal{L}_b`\ （训练结果矩阵输出头）和\ :math:`\mathcal{L}_c`\ （训练分类头）损失函数定义如下：

.. math:: \mathcal{L}_b = - \sum_{\{I,B\} \in D} \sum_{i,j} \frac{1}{N} \left( B_{i,j} \log \hat{B}_{i,j} + (1 - B_{i,j}) \log(1 - \hat{B}_{i,j}) \right)

.. math:: \mathcal{L}_c = - \sum_{\{I,c\} \in D} \left( c \log(\hat{c}) + (1 - c) \log(1 - \hat{c}) \right)

其中，\ :math:`D`\ 为训练数据集，包含独立制作的融合图像\ :math:`I`\ 和标签\ :math:`c`\ （类别为“真实”或者“融合”）。

.. _fig_5.6.2_IID_pipeline:

.. figure:: images/5.6.2_IID_pipeline.png
   :width: 810px

   IID算法流程 :cite:`huang2023implicit`



**隐式身份驱动的检测**
在最新（2024年）提出的检测算法中，\ *隐式身份驱动的*\ （Implicit
Identity Driven，IID） :cite:`huang2023implicit`
换脸检测算法有比较亮眼的表现。 如 :numref:`fig_5.6.2_IID_pipeline`
所示，IID方法基于人脸的身份信息来检测伪造的人脸。此方法认为伪造人脸图像中含有两种不同的身份信息，即源人脸和目标人脸的身份，而真实人脸图像中的两种身份信息是相同的。下面将详细介绍IID方法的训练和检测步骤。

首先，人脸交换是将源图片的人脸换成目标图片的人脸，并输出一张伪造出来的人脸。假脸对应的身份来自于源脸，且看起来像源脸，所以这种身份信息称为\ *显式身份*\ 。与此同时，假脸图片仍可能会包含目标脸的身份信息，这种身份信息称为\ *隐式身份*\ 。因此，给定一张人脸图像，可以将其分别嵌入到显式和隐式身份特征空间中，并使用两种特征之间的距离作为判断真假的依据：距离很近则为真，距离很远则为假。

基于上述假设，要解决的问题就是如何提取显示和隐式身份信息。IID方法提出将图像\ :math:`{\boldsymbol{x}}_i \in \mathbb{R}^{h \times w \times 3}`\ 输入到通用人脸识别模型\ :math:`f_{em}`\ 中得到其显式身份特征\ :math:`f_{em}({\boldsymbol{x}}_i)`\ 。此外，训练一个骨干网络作为隐式身份嵌入网络\ :math:`f_{im}`\ ，然后将图像输入到这个网络中得到嵌入特征向量\ :math:`f_{im}({\boldsymbol{x}}_i)`\ 。隐式身份嵌入网络使用下面定义的\ *显示身份对比*\ （Explicit
Identity Contrast，EIC）损失来训练：

.. math:: \mathcal{L}_{eic} = \frac{1}{N_F} \sum_{i \in F} \delta \left( f_{im}({\boldsymbol{x}}_i), f_{em}({\boldsymbol{x}}_i) \right) - \frac{1}{N_R} \sum_{i \in R} \delta \left( f_{im}({\boldsymbol{x}}_i), f_{em}({\boldsymbol{x}}_i) \right)

其中，\ :math:`R`\ 和\ :math:`F`\ 表示真实和伪造图片集合，\ :math:`N_R`\ 和\ :math:`N_F`\ 表示真实和伪造图片的数量，\ :math:`\delta(\cdot,\cdot)`\ 是余弦相似度。
可以看到在最小化EIC损失的时候，能够将虚假人脸的显式身份和隐式身份在隐式特征空间中拉远，而将真实人脸的距离拉近，这样正样本会收敛到其隐式身份（等同显式身份），而负样本则会自动区分隐显身份差异。

上述训练只是帮助区分了显示和隐式两种身份信息，但是并没有将伪造图像与其隐式身份做进一步的关联。
为此，IID方法将伪造图像和其隐式身份（也就是目标人脸）标注为同一个类别，然后利用下面的\ *隐式身份探索*\ （Implicit
Identity Exploration，IIE）损失来完成：

.. math:: \mathcal{L}_{iie}^{+} = -\mathbb{E}_{({\boldsymbol{x}}_i,y_i) \sim \mathcal{K}} \left[ \log \frac{e^{s (\cos (\theta_{y_i}) - m)}}{e^{s (\cos (\theta_{y_i}) - m)} + \sum_{j \neq y_i} e^{s \cos \theta_j}} \right]

其中，\ :math:`\theta_{j}`\ 表示归一化隐式特征向量\ :math:`f_{im}({\boldsymbol{x}}_i)`\ 和在高维特征空间中,第\ :math:`j`\ 个身份的归一化代理向量之间的角度，\ :math:`s`\ 是特征缩放，\ :math:`m`\ 是间隔超参数。此外，间隔\ :math:`m`\ 对于伪造人脸来说是动态变化的：

.. math:: m_{fake} = \alpha \cdot \frac{1}{N_r} \sum_{i \in R_{mini}} \cos (\theta_{y_i})

其中，\ :math:`R_{mini}`\ 表示一小批真实样本集，这保证了在真实人脸收敛之后间隔才发挥作用，也是强力约束的关键。

此外，IID还需要让同一伪造视频的不同帧之间保持隐式身份一致。首先给样本\ :math:`{\boldsymbol{x}}_i`\ 一个未知隐式身份标签\ :math:`y_i^*`\ ，同时给同一视频的其他帧相同的身份。以此为基础，将所有帧的隐式特征向量抽取出来并存放在表\ :math:`V`\ 中。在前向传播过程中计算\ :math:`f_{im}({\boldsymbol{x}}_i)`\ 和向量表的距离\ :math:`V^T f_{im}({\boldsymbol{x}}_i)`\ ，同时在反向传播的时候更新表中\ :math:`y_i^*`\ 列所对应的向量\ :math:`{\boldsymbol{v}}_{y_i^*} \gets \beta {\boldsymbol{v}}_{y_i^*} + (1 - \beta) f_{im}({\boldsymbol{x}}_i)`\ ，其中\ :math:`\beta \in [0,1]`\ 超参数。通过Softmax函数定义样本\ :math:`{\boldsymbol{x}}_i`\ 被分类为\ :math:`y_i^*`\ 的概率，并最大化对数似然函数的期望：

.. math:: \mathcal{L}_{iie}^{-} = -\mathbb{E}_{({\boldsymbol{x}}_i, y_i^*) \sim \mathcal{U}} \left[ \log \frac{e^{\left( {\boldsymbol{v}}_{y_i^*}^T f_{im}({\boldsymbol{x}}_i) / \tau \right)}}{\sum_{j=1}^{Q} e^{\left( {\boldsymbol{v}}_j^T f_{im}({\boldsymbol{x}}_i) / \tau \right)}} \right]

其中，\ :math:`\tau`\ 为温度超参数。

结合上述各损失函数最终得到IID方法的完整损失函数：

.. math:: \mathcal{L} = \mathcal{L}_{bce} + \lambda_1 \mathcal{L}_{eic} + \lambda_2 (\mathcal{L}_{iie}^{+} + \mathcal{L}_{iie}^{-})

其中，\ :math:`\mathcal{L}_{bce}`\ 是二元交叉熵损失函数。

与此前的F3net 和 Face X-ray 相比，IID
方法在多个数据集上都取得了更优异的性能。这体现了该方法在深度伪造检测方面的独到之处。虽然先进的检测方法正在不断的被提出，生成式人工智能技术的快速发展势必会带来更多样化、更复杂、更难以分辨的伪造内容，所以深度伪造检测任务依然十分严峻。我们需要持续不懈的研究探索，才能够及时应对不断升级的人工智能生成虚假内容威胁。

本章小结
--------

本章介绍了针对视觉ViT模型的各类攻防方法。其中，章节
:numref:`sec_adv_attack`
介绍了对抗攻击方法，包括白盒攻击、迁移攻击和查询攻击；章节
:numref:`sec_adv_defense`
介绍了对抗防御方法，包括大规模对抗训练、对抗微调和扩散净化；章节
:numref:`sec_bd_attack`
介绍了后门攻击，包括无数据后门、图像块后门、多触发器后门和量化后门；章节
:numref:`sec_bd_defense`
介绍了后门防御，包括图像阻断、图像块处理以及图像块搜索；章节
:numref:`sec_model_steal`
介绍了模型抽取攻击，包括Cont-Steal攻击和RAD攻击；章节
:numref:`sec_deepfake` 介绍了深度伪造的几个代表性生成和检测方法。
通过了解这些针对 ViT
模型的攻击和防御方法，读者可以大致了解当前在视觉大模型安全领域的研究进展，认识到各种潜在的安全威胁及应对这些威胁的最新技术手段。

习题
----

1. 简要说明在对抗攻击方面ViT是否比CNN更鲁棒，并阐述原因。
2. 列举三种对抗防御策略，并描述它们的基本思想。
3. 简要说明对抗攻击和后门攻击的区别是什么。
4. 解释性算法如PatchSearch如何在后门防御中发挥作用？请描述其工作原理及应用效果。
5. 简单解释什么是模型抽取攻击，并讨论该攻击方法是否可以与对抗攻击和后门攻击相结合。
6. 检测深度伪造视频的一般流程是什么？

.. [1]
   虽然很多ViT模型并不算是视觉大模型，但是大部分视觉大模型的基座都是ViT，所以本章关注的视觉大模型指即是ViT模型。
